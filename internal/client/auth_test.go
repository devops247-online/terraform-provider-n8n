package client

import (
	"net/http"
	"net/http/cookiejar"
	"net/http/httptest"
	"net/url"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"testing"
	"time"
)

func TestSessionAuth_ApplyAuth(t *testing.T) {
	tests := []struct {
		name       string
		cookieFile string
	}{
		{
			name:       "empty cookie file",
			cookieFile: "",
		},
		{
			name:       "with cookie file",
			cookieFile: "/tmp/cookies.txt",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			auth := &SessionAuth{
				CookieFile: tt.cookieFile,
			}

			req, _ := http.NewRequest("GET", "http://example.com", nil)
			err := auth.ApplyAuth(req)

			// SessionAuth.ApplyAuth should never return error as it just relies on cookies
			if err != nil {
				t.Errorf("Unexpected error: %v", err)
			}
		})
	}
}

func TestAPIKeyAuth_ApplyAuth(t *testing.T) {
	tests := []struct {
		name   string
		apiKey string
	}{
		{
			name:   "standard api key",
			apiKey: "test-api-key-123",
		},
		{
			name:   "empty api key",
			apiKey: "",
		},
		{
			name:   "special characters",
			apiKey: "key-with-special-chars!@#",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			auth := &APIKeyAuth{APIKey: tt.apiKey}
			req, _ := http.NewRequest("GET", "http://example.com", nil)

			err := auth.ApplyAuth(req)
			if err != nil {
				t.Errorf("Unexpected error: %v", err)
			}

			if req.Header.Get("X-N8N-API-KEY") != tt.apiKey {
				t.Errorf("Expected X-N8N-API-KEY header to be %q, got %q", tt.apiKey, req.Header.Get("X-N8N-API-KEY"))
			}
		})
	}
}

func TestBasicAuth_ApplyAuth(t *testing.T) {
	tests := []struct {
		name     string
		email    string
		password string
	}{
		{
			name:     "standard credentials",
			email:    "test@example.com",
			password: "password123",
		},
		{
			name:     "empty email",
			email:    "",
			password: "password123",
		},
		{
			name:     "empty password",
			email:    "test@example.com",
			password: "",
		},
		{
			name:     "special characters in password",
			email:    "test@example.com",
			password: "pass!@#$%^&*()",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			auth := &BasicAuth{
				Email:    tt.email,
				Password: tt.password,
			}
			req, _ := http.NewRequest("GET", "http://example.com", nil)

			err := auth.ApplyAuth(req)
			if err != nil {
				t.Errorf("Unexpected error: %v", err)
			}

			username, password, ok := req.BasicAuth()
			if !ok {
				t.Error("Expected basic auth to be set")
			}

			if username != tt.email {
				t.Errorf("Expected username to be %q, got %q", tt.email, username)
			}

			if password != tt.password {
				t.Errorf("Expected password to be %q, got %q", tt.password, password)
			}
		})
	}
}

func TestSessionAuth_WithCookieJar(t *testing.T) {
	// Create a cookie jar with test cookies
	jar, err := cookiejar.New(nil)
	if err != nil {
		t.Fatalf("Failed to create cookie jar: %v", err)
	}

	targetURL, _ := url.Parse("https://example.com")
	cookies := []*http.Cookie{
		{
			Name:     "session_id",
			Value:    "test_session_123",
			Domain:   "example.com",
			Path:     "/",
			HttpOnly: true,
			Secure:   true,
		},
		{
			Name:   "csrf_token",
			Value:  "csrf_abc123",
			Domain: "example.com",
			Path:   "/api",
		},
	}
	jar.SetCookies(targetURL, cookies)

	auth := &SessionAuth{
		CookieJar:  jar,
		CookieFile: "/tmp/test_cookies.txt",
	}

	req, _ := http.NewRequest("GET", "https://example.com/api", nil)
	err = auth.ApplyAuth(req)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	// Session auth doesn't set headers directly - cookies are handled by the HTTP client
	// This test verifies that ApplyAuth doesn't interfere with the cookie mechanism
}

func TestSessionAuth_Integration(t *testing.T) {
	// Create a temporary cookie file for testing
	tempDir, err := os.MkdirTemp("", "session_auth_test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	cookieFile := filepath.Join(tempDir, "test_cookies.txt")

	// Create a test server that expects session cookies
	server := httptest.NewTLSServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Check for session cookie
		sessionCookie, err := r.Cookie("session_id")
		if err != nil || sessionCookie.Value != "valid_session_token" {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte(`{"status": "authenticated"}`))
	}))
	defer server.Close()

	_, _ = url.Parse(server.URL)

	// Write a valid cookie file
	futureTimestamp := time.Now().Add(24 * time.Hour).Unix()
	cookieContent := strings.Replace(server.URL, "https://", "", 1)
	domain := strings.Split(cookieContent, ":")[0]

	cookieFileContent := strings.Join([]string{
		"# Netscape HTTP Cookie File",
		"# Generated by test",
		domain + "\tTRUE\t/\tTRUE\t" + strconv.FormatInt(futureTimestamp, 10) + "\tsession_id\tvalid_session_token",
	}, "\n")

	err = os.WriteFile(cookieFile, []byte(cookieFileContent), 0600)
	if err != nil {
		t.Fatalf("Failed to write cookie file: %v", err)
	}

	// Test session authentication
	config := &Config{
		BaseURL:            server.URL,
		Auth:               &SessionAuth{CookieFile: cookieFile},
		InsecureSkipVerify: true, // For test server
	}

	client, err := NewClient(config)
	if err != nil {
		t.Fatalf("Failed to create client: %v", err)
	}

	var result map[string]interface{}
	err = client.Get("test", &result)
	if err != nil {
		t.Errorf("Request with session auth failed: %v", err)
	}

	if result["status"] != "authenticated" {
		t.Errorf("Expected authenticated response, got: %v", result)
	}
}

func TestSessionAuth_InvalidCookieFile(t *testing.T) {
	tests := []struct {
		name        string
		cookieFile  string
		wantErr     bool
		errContains string
	}{
		{
			name:        "nonexistent file",
			cookieFile:  "/nonexistent/path/cookies.txt",
			wantErr:     true,
			errContains: "failed to load cookies from file",
		},
		{
			name:        "invalid path traversal",
			cookieFile:  "../../../etc/passwd",
			wantErr:     true,
			errContains: "failed to load cookies from file",
		},
		{
			name:        "invalid extension",
			cookieFile:  "/tmp/cookies.exe",
			wantErr:     true,
			errContains: "failed to load cookies from file",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			config := &Config{
				BaseURL: "https://example.com",
				Auth:    &SessionAuth{CookieFile: tt.cookieFile},
			}

			_, err := NewClient(config)

			if tt.wantErr {
				if err == nil {
					t.Error("Expected error but got none")
					return
				}
				if !strings.Contains(err.Error(), tt.errContains) {
					t.Errorf("Expected error to contain %q, got %q", tt.errContains, err.Error())
				}
			} else {
				if err != nil {
					t.Errorf("Unexpected error: %v", err)
				}
			}
		})
	}
}

func TestSessionAuth_EmptyCookieFile(t *testing.T) {
	tempDir, err := os.MkdirTemp("", "empty_cookie_test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	cookieFile := filepath.Join(tempDir, "empty_cookies.txt")
	err = os.WriteFile(cookieFile, []byte("# Empty cookie file\n"), 0600)
	if err != nil {
		t.Fatalf("Failed to write empty cookie file: %v", err)
	}

	config := &Config{
		BaseURL: "https://example.com",
		Auth:    &SessionAuth{CookieFile: cookieFile},
	}

	client, err := NewClient(config)
	if err != nil {
		t.Errorf("Failed to create client with empty cookie file: %v", err)
	}

	if client == nil {
		t.Error("Expected client to be created even with empty cookie file")
	}
}

func TestSessionAuth_CookieJarIntegration(t *testing.T) {
	// Test that session auth properly integrates with HTTP client cookie jar
	jar, err := cookiejar.New(nil)
	if err != nil {
		t.Fatalf("Failed to create cookie jar: %v", err)
	}

	targetURL, _ := url.Parse("https://n8n.example.com")

	// Set some test cookies
	cookies := []*http.Cookie{
		{
			Name:     "n8n_session",
			Value:    "session_token_123",
			Domain:   "n8n.example.com",
			Path:     "/",
			Expires:  time.Now().Add(24 * time.Hour),
			HttpOnly: true,
			Secure:   true,
		},
		{
			Name:   "user_preferences",
			Value:  "theme=dark&lang=en",
			Domain: "n8n.example.com",
			Path:   "/api",
		},
	}
	jar.SetCookies(targetURL, cookies)

	auth := &SessionAuth{
		CookieJar: jar,
	}

	// Verify ApplyAuth doesn't interfere
	req, _ := http.NewRequest("GET", "https://n8n.example.com/api/workflows", nil)
	err = auth.ApplyAuth(req)
	if err != nil {
		t.Errorf("SessionAuth.ApplyAuth() error = %v", err)
	}

	// The actual cookie sending is handled by the HTTP client, not ApplyAuth
	// This test ensures ApplyAuth is compatible with cookie jar usage
}

func TestSessionAuth_ConcurrentAccess(t *testing.T) {
	// Test that SessionAuth is safe for concurrent use
	auth := &SessionAuth{
		CookieFile: "/tmp/test_cookies.txt",
	}

	const numGoroutines = 10
	done := make(chan bool, numGoroutines)

	for i := 0; i < numGoroutines; i++ {
		go func() {
			defer func() { done <- true }()

			req, _ := http.NewRequest("GET", "https://example.com", nil)
			err := auth.ApplyAuth(req)
			if err != nil {
				t.Errorf("Concurrent SessionAuth.ApplyAuth() error = %v", err)
			}
		}()
	}

	// Wait for all goroutines to complete
	for i := 0; i < numGoroutines; i++ {
		<-done
	}
}
