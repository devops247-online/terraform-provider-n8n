
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/devops247-online/terraform-provider-n8n/internal/client/client.go (51.6%)</option>

				<option value="file1">github.com/devops247-online/terraform-provider-n8n/internal/client/credentials.go (72.1%)</option>

				<option value="file2">github.com/devops247-online/terraform-provider-n8n/internal/client/ldap.go (83.3%)</option>

				<option value="file3">github.com/devops247-online/terraform-provider-n8n/internal/client/projects.go (56.2%)</option>

				<option value="file4">github.com/devops247-online/terraform-provider-n8n/internal/client/test_helpers.go (79.2%)</option>

				<option value="file5">github.com/devops247-online/terraform-provider-n8n/internal/client/users.go (78.9%)</option>

				<option value="file6">github.com/devops247-online/terraform-provider-n8n/internal/client/workflows.go (90.1%)</option>

				<option value="file7">github.com/devops247-online/terraform-provider-n8n/internal/provider/credential_resource.go (0.7%)</option>

				<option value="file8">github.com/devops247-online/terraform-provider-n8n/internal/provider/ldap_config_resource.go (1.8%)</option>

				<option value="file9">github.com/devops247-online/terraform-provider-n8n/internal/provider/project_resource.go (1.3%)</option>

				<option value="file10">github.com/devops247-online/terraform-provider-n8n/internal/provider/project_user_resource.go (1.5%)</option>

				<option value="file11">github.com/devops247-online/terraform-provider-n8n/internal/provider/provider.go (17.0%)</option>

				<option value="file12">github.com/devops247-online/terraform-provider-n8n/internal/provider/user_data_source.go (1.7%)</option>

				<option value="file13">github.com/devops247-online/terraform-provider-n8n/internal/provider/user_resource.go (1.2%)</option>

				<option value="file14">github.com/devops247-online/terraform-provider-n8n/internal/provider/workflow_resource.go (0.5%)</option>

				<option value="file15">github.com/devops247-online/terraform-provider-n8n/main.go (0.0%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">package client

import (
        "bufio"
        "bytes"
        "crypto/tls"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "math"
        "net/http"
        "net/http/cookiejar"
        "net/url"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"
)

// Client represents the n8n API client
type Client struct {
        baseURL     *url.URL
        httpClient  *http.Client
        auth        AuthMethod
        logger      Logger
        retryConfig RetryConfig
}

// Logger interface for logging requests and responses
type Logger interface {
        Logf(format string, args ...any)
}

// DefaultLogger implements Logger using the standard log package
type DefaultLogger struct{}

func (l *DefaultLogger) Logf(format string, args ...any) <span class="cov10" title="172">{
        log.Printf(format, args...)
}</span>

// RetryConfig holds retry configuration
type RetryConfig struct {
        MaxRetries int
        BaseDelay  time.Duration
        MaxDelay   time.Duration
}

// Config holds configuration for the n8n client
type Config struct {
        BaseURL            string
        Auth               AuthMethod
        InsecureSkipVerify bool
        Timeout            time.Duration
        Logger             Logger
        RetryConfig        RetryConfig
        CookieFile         string // Path to cookie file for session authentication
}

// AuthMethod interface for different authentication methods
type AuthMethod interface {
        ApplyAuth(*http.Request) error
}

// APIKeyAuth implements API key authentication
type APIKeyAuth struct {
        APIKey string
}

func (a *APIKeyAuth) ApplyAuth(req *http.Request) error <span class="cov8" title="63">{
        req.Header.Set("X-N8N-API-KEY", a.APIKey)
        return nil
}</span>

// BasicAuth implements basic authentication
type BasicAuth struct {
        Email    string
        Password string
}

func (a *BasicAuth) ApplyAuth(req *http.Request) error <span class="cov3" title="5">{
        req.SetBasicAuth(a.Email, a.Password)
        return nil
}</span>

// SessionAuth implements session-based authentication using cookies
type SessionAuth struct {
        CookieJar  http.CookieJar
        CookieFile string
}

func (a *SessionAuth) ApplyAuth(req *http.Request) error <span class="cov2" title="2">{
        // Session authentication is handled via cookies in the HTTP client
        // No additional headers needed as cookies are automatically sent
        return nil
}</span>

// validateCookieFilePath validates that the cookie file path is safe to open
func validateCookieFilePath(cookieFile string) error <span class="cov0" title="0">{
        if cookieFile == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("cookie file path cannot be empty")
        }</span>

        // Clean the path to resolve any .. or . components
        <span class="cov0" title="0">cleanPath := filepath.Clean(cookieFile)

        // Check for path traversal attempts
        if strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                return fmt.Errorf("cookie file path contains invalid path traversal: %s", cookieFile)
        }</span>

        <span class="cov0" title="0">if err := validateAbsolutePath(cleanPath, cookieFile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return validateFileExtension(cleanPath)</span>
}

// validateAbsolutePath checks if absolute paths are in allowed directories
func validateAbsolutePath(cleanPath, originalPath string) error <span class="cov0" title="0">{
        if !filepath.IsAbs(cleanPath) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">allowedDirs := getAllowedDirectories()
        for _, allowedDir := range allowedDirs </span><span class="cov0" title="0">{
                if strings.HasPrefix(cleanPath, filepath.Clean(allowedDir)) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("cookie file path outside allowed directories: %s", originalPath)</span>
}

// getAllowedDirectories returns list of safe directories for cookie files
func getAllowedDirectories() []string <span class="cov0" title="0">{
        allowedDirs := []string{"/tmp", "/var/tmp", os.TempDir()}

        if homeDir, err := os.UserHomeDir(); err == nil </span><span class="cov0" title="0">{
                allowedDirs = append(allowedDirs, homeDir)
        }</span>
        <span class="cov0" title="0">if cwd, err := os.Getwd(); err == nil </span><span class="cov0" title="0">{
                allowedDirs = append(allowedDirs, cwd)
        }</span>

        <span class="cov0" title="0">return allowedDirs</span>
}

// validateFileExtension checks if the file extension is allowed
func validateFileExtension(cleanPath string) error <span class="cov0" title="0">{
        ext := filepath.Ext(cleanPath)
        allowedExts := []string{".txt", ".cookies", ".cookie", ""}

        for _, allowedExt := range allowedExts </span><span class="cov0" title="0">{
                if ext == allowedExt </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("cookie file has invalid extension: %s (allowed: .txt, .cookies, .cookie, or no extension)", ext)</span>
}

// LoadCookiesFromFile loads cookies from a Netscape format cookie file
func LoadCookiesFromFile(cookieFile string, targetURL *url.URL) (http.CookieJar, error) <span class="cov0" title="0">{
        // Validate the cookie file path for security
        if err := validateCookieFilePath(cookieFile); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid cookie file path: %w", err)
        }</span>

        <span class="cov0" title="0">jar, err := cookiejar.New(nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cookie jar: %w", err)
        }</span>

        // Use the cleaned path
        <span class="cov0" title="0">cleanPath := filepath.Clean(cookieFile)
        file, err := os.Open(cleanPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open cookie file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        var cookies []*http.Cookie
        scanner := bufio.NewScanner(file)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())

                // Skip comments and empty lines
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse Netscape cookie format: domain \t flag \t path \t secure \t expiration \t name \t value
                <span class="cov0" title="0">parts := strings.Split(line, "\t")
                if len(parts) &lt; 7 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">domain := parts[0]
                path := parts[2]
                secure := parts[3] == "TRUE"
                expiration := parts[4]
                name := parts[5]
                value := parts[6]

                // Convert expiration timestamp
                var expires time.Time
                if expiration != "0" </span><span class="cov0" title="0">{
                        if timestamp, err := strconv.ParseInt(expiration, 10, 64); err == nil </span><span class="cov0" title="0">{
                                expires = time.Unix(timestamp, 0)
                        }</span>
                }

                // Skip expired cookies
                <span class="cov0" title="0">if !expires.IsZero() &amp;&amp; expires.Before(time.Now()) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">cookie := &amp;http.Cookie{
                        Name:     name,
                        Value:    value,
                        Domain:   strings.TrimPrefix(domain, "."),
                        Path:     path,
                        Expires:  expires,
                        Secure:   secure,
                        HttpOnly: strings.HasPrefix(domain, "#HttpOnly_"),
                }

                cookies = append(cookies, cookie)</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading cookie file: %w", err)
        }</span>

        // Set cookies in jar
        <span class="cov0" title="0">if len(cookies) &gt; 0 </span><span class="cov0" title="0">{
                jar.SetCookies(targetURL, cookies)
        }</span>

        <span class="cov0" title="0">return jar, nil</span>
}

// APIError represents an error response from the n8n API
type APIError struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
        Details string `json:"details,omitempty"`
}

func (e *APIError) Error() string <span class="cov3" title="5">{
        if e.Details != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("n8n API error (code %d): %s - %s", e.Code, e.Message, e.Details)
        }</span>
        <span class="cov3" title="5">return fmt.Sprintf("n8n API error (code %d): %s", e.Code, e.Message)</span>
}

// NewClient creates a new n8n API client
func NewClient(config *Config) (*Client, error) <span class="cov8" title="60">{
        if config.BaseURL == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("base URL is required")
        }</span>

        <span class="cov8" title="59">if config.Auth == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("authentication method is required")
        }</span>

        <span class="cov8" title="58">baseURL, err := url.Parse(config.BaseURL)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid base URL: %w", err)
        }</span>

        // Ensure the base URL has a trailing slash and api path
        <span class="cov8" title="57">if !strings.HasSuffix(baseURL.Path, "/") </span><span class="cov8" title="57">{
                baseURL.Path += "/"
        }</span>
        <span class="cov8" title="57">if !strings.HasSuffix(baseURL.Path, "api/v1/") </span><span class="cov8" title="57">{
                baseURL.Path += "api/v1/"
        }</span>

        <span class="cov8" title="57">timeout := config.Timeout
        if timeout == 0 </span><span class="cov7" title="46">{
                timeout = 30 * time.Second
        }</span>

        // Configure TLS settings
        <span class="cov8" title="57">transport := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{
                        // InsecureSkipVerify should only be used for development/testing environments
                        // with self-signed certificates. In production, proper certificate validation
                        // should be used to prevent man-in-the-middle attacks.
                        InsecureSkipVerify: config.InsecureSkipVerify, // #nosec G402 - Configurable for development environments
                },
        }

        httpClient := &amp;http.Client{
                Timeout:   timeout,
                Transport: transport,
        }

        // If using session authentication, set up cookie jar
        if sessionAuth, ok := config.Auth.(*SessionAuth); ok &amp;&amp; sessionAuth.CookieFile != "" </span><span class="cov0" title="0">{
                cookieJar, err := LoadCookiesFromFile(sessionAuth.CookieFile, baseURL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load cookies from file: %w", err)
                }</span>
                <span class="cov0" title="0">httpClient.Jar = cookieJar
                sessionAuth.CookieJar = cookieJar</span>
        }

        <span class="cov8" title="57">logger := config.Logger
        if logger == nil </span><span class="cov8" title="56">{
                logger = &amp;DefaultLogger{}
        }</span>

        <span class="cov8" title="57">retryConfig := config.RetryConfig
        if retryConfig.MaxRetries == 0 </span><span class="cov7" title="54">{
                retryConfig.MaxRetries = 3
        }</span>
        <span class="cov8" title="57">if retryConfig.BaseDelay == 0 </span><span class="cov7" title="54">{
                retryConfig.BaseDelay = 100 * time.Millisecond
        }</span>
        <span class="cov8" title="57">if retryConfig.MaxDelay == 0 </span><span class="cov7" title="54">{
                retryConfig.MaxDelay = 5 * time.Second
        }</span>

        <span class="cov8" title="57">return &amp;Client{
                baseURL:     baseURL,
                httpClient:  httpClient,
                auth:        config.Auth,
                logger:      logger,
                retryConfig: retryConfig,
        }, nil</span>
}

// doRequest performs an HTTP request with authentication, retries, and logging
func (c *Client) doRequest(method, path string, body any, result any) error <span class="cov7" title="49">{
        var jsonData []byte
        var err error

        if body != nil </span><span class="cov5" title="11">{
                jsonData, err = json.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal request body: %w", err)
                }</span>
        }

        // Construct full URL
        <span class="cov7" title="49">var fullURL *url.URL
        if strings.Contains(path, "?") </span><span class="cov2" title="3">{
                // Path contains query parameters, parse it properly
                pathURL, err := url.Parse(path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse path with query: %w", err)
                }</span>
                <span class="cov2" title="3">fullURL = c.baseURL.ResolveReference(pathURL)</span>
        } else<span class="cov7" title="46"> {
                // Simple path without query parameters
                fullURL = c.baseURL.ResolveReference(&amp;url.URL{Path: path})
        }</span>

        <span class="cov7" title="49">for attempt := 0; attempt &lt;= c.retryConfig.MaxRetries; attempt++ </span><span class="cov8" title="59">{
                var reqBody io.Reader
                if jsonData != nil </span><span class="cov5" title="11">{
                        reqBody = bytes.NewBuffer(jsonData)
                }</span>

                <span class="cov8" title="59">req, err := http.NewRequest(method, fullURL.String(), reqBody)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create request: %w", err)
                }</span>

                // Set headers
                <span class="cov8" title="59">req.Header.Set("Content-Type", "application/json")
                req.Header.Set("Accept", "application/json")

                // Apply authentication
                if err := c.auth.ApplyAuth(req); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to apply authentication: %w", err)
                }</span>

                // Log request
                <span class="cov8" title="59">c.logger.Logf("n8n API request: %s %s (attempt %d/%d)", method, fullURL.String(), attempt+1, c.retryConfig.MaxRetries+1)
                if len(jsonData) &gt; 0 </span><span class="cov5" title="11">{
                        c.logger.Logf("n8n API request body: %s", string(jsonData))
                }</span>

                <span class="cov8" title="59">resp, err := c.httpClient.Do(req)
                if err != nil </span><span class="cov4" title="6">{
                        if attempt &lt; c.retryConfig.MaxRetries &amp;&amp; isRetryableError(err) </span><span class="cov2" title="3">{
                                delay := c.calculateBackoff(attempt)
                                c.logger.Logf("n8n API request failed, retrying in %v: %v", delay, err)
                                time.Sleep(delay)
                                continue</span>
                        }
                        <span class="cov2" title="3">return fmt.Errorf("request failed: %w", err)</span>
                }

                // Ensure response body is properly closed
                <span class="cov7" title="53">defer func() </span><span class="cov7" title="53">{
                        if closeErr := resp.Body.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                c.logger.Logf("Warning: failed to close response body: %v", closeErr)
                        }</span>
                }()

                <span class="cov7" title="53">respBody, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read response body: %w", err)
                }</span>

                // Log response
                <span class="cov7" title="53">c.logger.Logf("n8n API response: %d %s", resp.StatusCode, resp.Status)
                if len(respBody) &gt; 0 </span><span class="cov7" title="42">{
                        c.logger.Logf("n8n API response body: %s", string(respBody))
                }</span>

                // Handle error responses
                <span class="cov7" title="53">if resp.StatusCode &gt;= 400 </span><span class="cov5" title="14">{
                        // Check if this is a retryable HTTP error
                        if attempt &lt; c.retryConfig.MaxRetries &amp;&amp; isRetryableHTTPStatus(resp.StatusCode) </span><span class="cov4" title="7">{
                                delay := c.calculateBackoff(attempt)
                                c.logger.Logf("n8n API request failed with status %d, retrying in %v", resp.StatusCode, delay)
                                time.Sleep(delay)
                                continue</span>
                        }

                        <span class="cov4" title="7">var apiErr APIError
                        if err := json.Unmarshal(respBody, &amp;apiErr); err != nil </span><span class="cov1" title="1">{
                                // If we can't parse the error response, create a generic error
                                return &amp;APIError{
                                        Code:    resp.StatusCode,
                                        Message: fmt.Sprintf("HTTP %d: %s", resp.StatusCode, string(respBody)),
                                }
                        }</span>
                        <span class="cov4" title="6">apiErr.Code = resp.StatusCode
                        return &amp;apiErr</span>
                }

                // Parse successful response
                <span class="cov7" title="39">if result != nil &amp;&amp; len(respBody) &gt; 0 </span><span class="cov7" title="33">{
                        if err := json.Unmarshal(respBody, result); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to unmarshal response: %w", err)
                        }</span>
                }

                <span class="cov7" title="38">return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("max retries exceeded")</span>
}

// calculateBackoff calculates exponential backoff delay
func (c *Client) calculateBackoff(attempt int) time.Duration <span class="cov5" title="14">{
        delay := time.Duration(float64(c.retryConfig.BaseDelay) * math.Pow(2, float64(attempt)))
        return min(delay, c.retryConfig.MaxDelay)
}</span>

// isRetryableError determines if an error is retryable
func isRetryableError(err error) bool <span class="cov3" title="5">{
        // Network errors are generally retryable
        return strings.Contains(err.Error(), "timeout") ||
                strings.Contains(err.Error(), "connection refused") ||
                strings.Contains(err.Error(), "connection reset")
}</span>

// isRetryableHTTPStatus determines if an HTTP status code is retryable
func isRetryableHTTPStatus(statusCode int) bool <span class="cov5" title="12">{
        return statusCode == http.StatusTooManyRequests ||
                statusCode == http.StatusInternalServerError ||
                statusCode == http.StatusBadGateway ||
                statusCode == http.StatusServiceUnavailable ||
                statusCode == http.StatusGatewayTimeout
}</span>

// Get performs a GET request
func (c *Client) Get(path string, result any) error <span class="cov6" title="18">{
        return c.doRequest("GET", path, nil, result)
}</span>

// Post performs a POST request
func (c *Client) Post(path string, body any, result any) error <span class="cov4" title="9">{
        return c.doRequest("POST", path, body, result)
}</span>

// Put performs a PUT request
func (c *Client) Put(path string, body any, result any) error <span class="cov3" title="5">{
        return c.doRequest("PUT", path, body, result)
}</span>

// Delete performs a DELETE request
func (c *Client) Delete(path string) error <span class="cov3" title="5">{
        return c.doRequest("DELETE", path, nil, nil)
}</span>

// PaginationInfo holds pagination metadata
type PaginationInfo struct {
        Limit      int    `json:"limit,omitempty"`
        Offset     int    `json:"offset,omitempty"`
        Total      int    `json:"total,omitempty"`
        NextCursor string `json:"nextCursor,omitempty"`
        HasNext    bool   `json:"hasNext,omitempty"`
}

// GetWithPagination performs a GET request with pagination support
func (c *Client) GetWithPagination(path string, result any) (*PaginationInfo, error) <span class="cov0" title="0">{
        err := c.doRequest("GET", path, nil, result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Try to extract pagination info from the response
        // This is a best-effort approach since different endpoints might return different formats
        <span class="cov0" title="0">pagination := &amp;PaginationInfo{}

        // If result is a map, try to extract pagination fields
        if resultMap, ok := result.(*map[string]any); ok </span><span class="cov0" title="0">{
                if nextCursor, exists := (*resultMap)["nextCursor"]; exists </span><span class="cov0" title="0">{
                        if cursorStr, ok := nextCursor.(string); ok </span><span class="cov0" title="0">{
                                pagination.NextCursor = cursorStr
                                pagination.HasNext = cursorStr != ""
                        }</span>
                }
                <span class="cov0" title="0">if total, exists := (*resultMap)["total"]; exists </span><span class="cov0" title="0">{
                        if totalFloat, ok := total.(float64); ok </span><span class="cov0" title="0">{
                                pagination.Total = int(totalFloat)
                        }</span>
                }
        }

        <span class="cov0" title="0">return pagination, nil</span>
}
</pre>

		<pre class="file" id="file1" style="display: none">package client

import (
        "fmt"
        "net/url"
        "strconv"
        "time"
)

// Credential represents an n8n credential
type Credential struct {
        ID         string                 `json:"id,omitempty"`
        Name       string                 `json:"name"`
        Type       string                 `json:"type"`
        Data       map[string]interface{} `json:"data"`
        SharedWith []string               `json:"sharedWith,omitempty"`
        ProjectID  string                 `json:"projectId,omitempty"`
        CreatedAt  *time.Time             `json:"createdAt,omitempty"`
        UpdatedAt  *time.Time             `json:"updatedAt,omitempty"`
}

// CredentialListOptions represents options for listing credentials
type CredentialListOptions struct {
        Type      string
        ProjectID string
        Limit     int
        Offset    int
}

// CredentialListResponse represents the response from listing credentials
type CredentialListResponse struct {
        Data       []Credential `json:"data"`
        NextCursor string       `json:"nextCursor,omitempty"`
}

// GetCredentials retrieves a list of credentials
func (c *Client) GetCredentials(options *CredentialListOptions) (*CredentialListResponse, error) <span class="cov5" title="2">{
        u, err := url.Parse("credentials")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse URL: %w", err)
        }</span>

        <span class="cov5" title="2">if options != nil </span><span class="cov1" title="1">{
                params := url.Values{}

                if options.Type != "" </span><span class="cov1" title="1">{
                        params.Set("type", options.Type)
                }</span>

                <span class="cov1" title="1">if options.ProjectID != "" </span><span class="cov0" title="0">{
                        params.Set("projectId", options.ProjectID)
                }</span>

                <span class="cov1" title="1">if options.Limit &gt; 0 </span><span class="cov1" title="1">{
                        params.Set("limit", strconv.Itoa(options.Limit))
                }</span>

                <span class="cov1" title="1">if options.Offset &gt; 0 </span><span class="cov0" title="0">{
                        params.Set("offset", strconv.Itoa(options.Offset))
                }</span>

                <span class="cov1" title="1">u.RawQuery = params.Encode()</span>
        }

        <span class="cov5" title="2">var result CredentialListResponse
        err = c.Get(u.String(), &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get credentials: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;result, nil</span>
}

// GetCredential retrieves a specific credential by ID
func (c *Client) GetCredential(id string) (*Credential, error) <span class="cov5" title="2">{
        if id == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("credential ID is required")
        }</span>

        // Try direct endpoint first
        <span class="cov1" title="1">path := fmt.Sprintf("credentials/%s", id)
        var credential Credential
        err := c.Get(path, &amp;credential)
        if err == nil </span><span class="cov1" title="1">{
                return &amp;credential, nil
        }</span>

        // If direct endpoint fails, fall back to list and filter
        // This is needed for some n8n versions that don't support individual credential GET
        <span class="cov0" title="0">credentials, listErr := c.GetCredentials(nil)
        if listErr != nil </span><span class="cov0" title="0">{
                // Return original error if list also fails
                return nil, fmt.Errorf("failed to get credential %s: %w", id, err)
        }</span>

        // Find credential by ID in the list
        <span class="cov0" title="0">for _, cred := range credentials.Data </span><span class="cov0" title="0">{
                if cred.ID == id </span><span class="cov0" title="0">{
                        return &amp;cred, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("credential %s not found", id)</span>
}

// CreateCredential creates a new credential
func (c *Client) CreateCredential(credential *Credential) (*Credential, error) <span class="cov10" title="4">{
        if credential == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("credential is required")
        }</span>

        <span class="cov8" title="3">if credential.Name == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("credential name is required")
        }</span>

        <span class="cov5" title="2">if credential.Type == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("credential type is required")
        }</span>

        <span class="cov1" title="1">var result Credential
        err := c.Post("credentials", credential, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create credential: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;result, nil</span>
}

// UpdateCredential updates an existing credential
func (c *Client) UpdateCredential(id string, credential *Credential) (*Credential, error) <span class="cov1" title="1">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("credential ID is required")
        }</span>

        <span class="cov1" title="1">if credential == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("credential is required")
        }</span>

        <span class="cov1" title="1">path := fmt.Sprintf("credentials/%s", id)

        var result Credential
        err := c.Put(path, credential, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update credential %s: %w", id, err)
        }</span>

        <span class="cov1" title="1">return &amp;result, nil</span>
}

// DeleteCredential deletes a credential
func (c *Client) DeleteCredential(id string) error <span class="cov1" title="1">{
        if id == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("credential ID is required")
        }</span>

        <span class="cov1" title="1">path := fmt.Sprintf("credentials/%s", id)

        err := c.Delete(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete credential %s: %w", id, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>

		<pre class="file" id="file2" style="display: none">package client

import (
        "fmt"
)

// LDAPConfig represents LDAP configuration (Enterprise feature)
type LDAPConfig struct {
        ServerURL              string `json:"serverUrl"`
        BindDN                 string `json:"bindDn"`
        BindPassword           string `json:"bindPassword"`
        SearchBase             string `json:"searchBase,omitempty"`
        SearchFilter           string `json:"searchFilter,omitempty"`
        UserIDAttribute        string `json:"userIdAttribute,omitempty"`
        UserEmailAttribute     string `json:"userEmailAttribute,omitempty"`
        UserFirstNameAttribute string `json:"userFirstNameAttribute,omitempty"`
        UserLastNameAttribute  string `json:"userLastNameAttribute,omitempty"`
        GroupSearchBase        string `json:"groupSearchBase,omitempty"`
        GroupSearchFilter      string `json:"groupSearchFilter,omitempty"`
        TLSEnabled             bool   `json:"tlsEnabled,omitempty"`
        CACertificate          string `json:"caCertificate,omitempty"`
}

// LDAPTestResult represents the result of testing LDAP connection
type LDAPTestResult struct {
        Success bool   `json:"success"`
        Message string `json:"message,omitempty"`
}

// GetLDAPConfig retrieves the current LDAP configuration
func (c *Client) GetLDAPConfig() (*LDAPConfig, error) <span class="cov1" title="1">{
        var config LDAPConfig
        err := c.Get("ldap/config", &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get LDAP config: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;config, nil</span>
}

// UpdateLDAPConfig updates the LDAP configuration
func (c *Client) UpdateLDAPConfig(config *LDAPConfig) (*LDAPConfig, error) <span class="cov10" title="5">{
        if config == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("LDAP config is required")
        }</span>

        <span class="cov8" title="4">if config.ServerURL == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("LDAP server URL is required")
        }</span>

        <span class="cov7" title="3">if config.BindDN == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("LDAP bind DN is required")
        }</span>

        <span class="cov4" title="2">if config.BindPassword == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("LDAP bind password is required")
        }</span>

        <span class="cov1" title="1">var result LDAPConfig
        err := c.Put("ldap/config", config, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update LDAP config: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;result, nil</span>
}

// TestLDAPConnection tests the LDAP connection with the current configuration
func (c *Client) TestLDAPConnection() (*LDAPTestResult, error) <span class="cov1" title="1">{
        var result LDAPTestResult
        err := c.Post("ldap/test", nil, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to test LDAP connection: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;result, nil</span>
}

// TestLDAPConnectionWithConfig tests the LDAP connection with a specific configuration
func (c *Client) TestLDAPConnectionWithConfig(config *LDAPConfig) (*LDAPTestResult, error) <span class="cov1" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LDAP config is required")
        }</span>

        <span class="cov1" title="1">var result LDAPTestResult
        err := c.Post("ldap/test", config, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to test LDAP connection: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;result, nil</span>
}
</pre>

		<pre class="file" id="file3" style="display: none">package client

import (
        "fmt"
        "net/url"
        "strconv"
        "time"
)

// Project represents an n8n project (Enterprise feature)
type Project struct {
        ID          string                 `json:"id,omitempty"`
        Name        string                 `json:"name"`
        Description string                 `json:"description,omitempty"`
        Settings    map[string]interface{} `json:"settings,omitempty"`
        Icon        string                 `json:"icon,omitempty"`
        Color       string                 `json:"color,omitempty"`
        OwnerID     string                 `json:"ownerId,omitempty"`
        MemberCount int                    `json:"memberCount,omitempty"`
        CreatedAt   *time.Time             `json:"createdAt,omitempty"`
        UpdatedAt   *time.Time             `json:"updatedAt,omitempty"`
}

// ProjectUser represents a user's membership in a project
type ProjectUser struct {
        ID        string     `json:"id,omitempty"`
        ProjectID string     `json:"projectId"`
        UserID    string     `json:"userId"`
        Role      string     `json:"role,omitempty"`
        AddedAt   *time.Time `json:"addedAt,omitempty"`
}

// ProjectListOptions represents options for listing projects
type ProjectListOptions struct {
        Limit  int
        Offset int
}

// ProjectListResponse represents the response from listing projects
type ProjectListResponse struct {
        Data       []Project `json:"data"`
        NextCursor string    `json:"nextCursor,omitempty"`
}

// GetProjects retrieves a list of projects
func (c *Client) GetProjects(options *ProjectListOptions) (*ProjectListResponse, error) <span class="cov8" title="1">{
        path := "projects"

        if options != nil </span><span class="cov0" title="0">{
                params := url.Values{}

                if options.Limit &gt; 0 </span><span class="cov0" title="0">{
                        params.Set("limit", strconv.Itoa(options.Limit))
                }</span>

                <span class="cov0" title="0">if options.Offset &gt; 0 </span><span class="cov0" title="0">{
                        params.Set("offset", strconv.Itoa(options.Offset))
                }</span>

                <span class="cov0" title="0">if len(params) &gt; 0 </span><span class="cov0" title="0">{
                        path += "?" + params.Encode()
                }</span>
        }

        <span class="cov8" title="1">var result ProjectListResponse
        err := c.Get(path, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get projects: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

// GetProject retrieves a specific project by ID
func (c *Client) GetProject(id string) (*Project, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project ID is required")
        }</span>

        <span class="cov8" title="1">path := fmt.Sprintf("projects/%s", id)

        var project Project
        err := c.Get(path, &amp;project)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get project %s: %w", id, err)
        }</span>

        <span class="cov8" title="1">return &amp;project, nil</span>
}

// CreateProject creates a new project
func (c *Client) CreateProject(project *Project) (*Project, error) <span class="cov8" title="1">{
        if project == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project is required")
        }</span>

        <span class="cov8" title="1">if project.Name == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project name is required")
        }</span>

        <span class="cov8" title="1">var result Project
        err := c.Post("projects", project, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create project: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

// UpdateProject updates an existing project
func (c *Client) UpdateProject(id string, project *Project) (*Project, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project ID is required")
        }</span>

        <span class="cov8" title="1">if project == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project is required")
        }</span>

        <span class="cov8" title="1">path := fmt.Sprintf("projects/%s", id)

        var result Project
        err := c.Put(path, project, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update project %s: %w", id, err)
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

// DeleteProject deletes a project
func (c *Client) DeleteProject(id string) error <span class="cov8" title="1">{
        if id == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("project ID is required")
        }</span>

        <span class="cov8" title="1">path := fmt.Sprintf("projects/%s", id)

        err := c.Delete(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete project %s: %w", id, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetProjectUsers retrieves users for a specific project
func (c *Client) GetProjectUsers(projectID string) ([]ProjectUser, error) <span class="cov8" title="1">{
        if projectID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project ID is required")
        }</span>

        <span class="cov8" title="1">path := fmt.Sprintf("projects/%s/users", projectID)

        var result struct {
                Data []ProjectUser `json:"data"`
        }
        err := c.Get(path, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get project users for project %s: %w", projectID, err)
        }</span>

        <span class="cov8" title="1">return result.Data, nil</span>
}

// AddUserToProject adds a user to a project
func (c *Client) AddUserToProject(projectUser *ProjectUser) (*ProjectUser, error) <span class="cov8" title="1">{
        if projectUser == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project user is required")
        }</span>

        <span class="cov8" title="1">if projectUser.ProjectID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project ID is required")
        }</span>

        <span class="cov8" title="1">if projectUser.UserID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user ID is required")
        }</span>

        <span class="cov8" title="1">path := fmt.Sprintf("projects/%s/users", projectUser.ProjectID)

        var result ProjectUser
        err := c.Post(path, projectUser, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add user to project: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

// UpdateProjectUser updates a user's role in a project
func (c *Client) UpdateProjectUser(projectID, userID string, projectUser *ProjectUser) (*ProjectUser, error) <span class="cov0" title="0">{
        if projectID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project ID is required")
        }</span>

        <span class="cov0" title="0">if userID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user ID is required")
        }</span>

        <span class="cov0" title="0">if projectUser == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project user is required")
        }</span>

        <span class="cov0" title="0">path := fmt.Sprintf("projects/%s/users/%s", projectID, userID)

        var result ProjectUser
        err := c.Put(path, projectUser, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update project user: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;result, nil</span>
}

// RemoveUserFromProject removes a user from a project
func (c *Client) RemoveUserFromProject(projectID, userID string) error <span class="cov8" title="1">{
        if projectID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("project ID is required")
        }</span>

        <span class="cov8" title="1">if userID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("user ID is required")
        }</span>

        <span class="cov8" title="1">path := fmt.Sprintf("projects/%s/users/%s", projectID, userID)

        err := c.Delete(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove user from project: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>

		<pre class="file" id="file4" style="display: none">package client

import (
        "encoding/json"
        "net/http"
        "net/http/httptest"
        "net/url"
        "testing"
)

// TestServer creates a test HTTP server for client testing
func TestServer(handler http.HandlerFunc) *httptest.Server <span class="cov5" title="4">{
        return httptest.NewServer(handler)
}</span>

// CreateTestClient creates a client configured for testing with the given server URL
func CreateTestClient(t *testing.T, serverURL string) *Client <span class="cov10" title="13">{
        t.Helper()

        config := &amp;Config{
                BaseURL: serverURL,
                Auth:    &amp;APIKeyAuth{APIKey: "test-key"},
        }

        client, err := NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("NewClient() error = %v", err)
        }</span>

        <span class="cov10" title="13">return client</span>
}

// DeleteTestHandler creates a generic DELETE request handler for testing
func DeleteTestHandler(t *testing.T, expectedPath string) http.HandlerFunc <span class="cov3" title="2">{
        t.Helper()

        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov3" title="2">{
                if r.Method != "DELETE" </span><span class="cov0" title="0">{
                        t.Errorf("Expected DELETE request, got %s", r.Method)
                }</span>

                <span class="cov3" title="2">if r.URL.Path != expectedPath </span><span class="cov0" title="0">{
                        t.Errorf("Expected path %s, got %s", expectedPath, r.URL.Path)
                }</span>

                <span class="cov3" title="2">w.WriteHeader(http.StatusNoContent)</span>
        }
}

// ListTestHandler creates a generic list request handler that validates query parameters
func ListTestHandler(t *testing.T, expectedQuery url.Values, responseData interface{}) http.HandlerFunc <span class="cov3" title="2">{
        t.Helper()

        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov3" title="2">{
                query := r.URL.Query()

                // Validate expected query parameters
                for key, expectedValues := range expectedQuery </span><span class="cov5" title="4">{
                        if len(expectedValues) &gt; 0 </span><span class="cov5" title="4">{
                                if query.Get(key) != expectedValues[0] </span><span class="cov0" title="0">{
                                        t.Errorf("Expected %s=%s, got %s", key, expectedValues[0], query.Get(key))
                                }</span>
                        }
                }

                <span class="cov3" title="2">w.Header().Set("Content-Type", "application/json")
                if err := json.NewEncoder(w).Encode(responseData); err != nil </span><span class="cov0" title="0">{
                        t.Errorf("Failed to encode response: %v", err)
                }</span>
        }
}
</pre>

		<pre class="file" id="file5" style="display: none">package client

import (
        "fmt"
        "net/url"
        "strconv"
        "time"
)

// User represents an n8n user
type User struct {
        ID          string       `json:"id,omitempty"`
        Email       string       `json:"email"`
        FirstName   string       `json:"firstName,omitempty"`
        LastName    string       `json:"lastName,omitempty"`
        Role        string       `json:"role,omitempty"`
        IsOwner     bool         `json:"isOwner,omitempty"`
        IsPending   bool         `json:"isPending,omitempty"`
        SignupToken string       `json:"signupToken,omitempty"`
        Settings    UserSettings `json:"settings,omitempty"`
        CreatedAt   *time.Time   `json:"createdAt,omitempty"`
        UpdatedAt   *time.Time   `json:"updatedAt,omitempty"`
}

// UserSettings represents user-specific settings
type UserSettings struct {
        Theme               string `json:"theme,omitempty"`
        AllowSSOManualLogin bool   `json:"allowSSOManualLogin,omitempty"`
}

// UserListOptions represents options for listing users
type UserListOptions struct {
        Role   string
        Limit  int
        Offset int
}

// UserListResponse represents the response from listing users
type UserListResponse struct {
        Data       []User `json:"data"`
        NextCursor string `json:"nextCursor,omitempty"`
}

// CreateUserRequest represents the request body for creating a user
type CreateUserRequest struct {
        Email     string `json:"email"`
        FirstName string `json:"firstName,omitempty"`
        LastName  string `json:"lastName,omitempty"`
        Role      string `json:"role,omitempty"`
        Password  string `json:"password,omitempty"`
}

// GetUsers retrieves a list of users
func (c *Client) GetUsers(options *UserListOptions) (*UserListResponse, error) <span class="cov6" title="2">{
        u, err := url.Parse("users")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse URL: %w", err)
        }</span>

        <span class="cov6" title="2">if options != nil </span><span class="cov1" title="1">{
                params := url.Values{}

                if options.Role != "" </span><span class="cov1" title="1">{
                        params.Set("role", options.Role)
                }</span>

                <span class="cov1" title="1">if options.Limit &gt; 0 </span><span class="cov1" title="1">{
                        params.Set("limit", strconv.Itoa(options.Limit))
                }</span>

                <span class="cov1" title="1">if options.Offset &gt; 0 </span><span class="cov0" title="0">{
                        params.Set("offset", strconv.Itoa(options.Offset))
                }</span>

                <span class="cov1" title="1">u.RawQuery = params.Encode()</span>
        }

        <span class="cov6" title="2">var result UserListResponse
        err = c.Get(u.String(), &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get users: %w", err)
        }</span>

        <span class="cov6" title="2">return &amp;result, nil</span>
}

// GetUser retrieves a specific user by ID
func (c *Client) GetUser(id string) (*User, error) <span class="cov6" title="2">{
        if id == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("user ID is required")
        }</span>

        <span class="cov1" title="1">path := fmt.Sprintf("users/%s", id)

        var user User
        err := c.Get(path, &amp;user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user %s: %w", id, err)
        }</span>

        <span class="cov1" title="1">return &amp;user, nil</span>
}

// CreateUser creates a new user
func (c *Client) CreateUser(userReq *CreateUserRequest) (*User, error) <span class="cov10" title="3">{
        if userReq == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("user request is required")
        }</span>

        <span class="cov6" title="2">if userReq.Email == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("user email is required")
        }</span>

        // n8n API expects an array of users, so wrap single user in array
        <span class="cov1" title="1">userArray := []*CreateUserRequest{userReq}

        // n8n returns array of {user: User, error: string} objects
        type CreateUserResponse struct {
                User  User   `json:"user"`
                Error string `json:"error"`
        }

        var resultArray []CreateUserResponse
        err := c.Post("users", userArray, &amp;resultArray)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov1" title="1">if len(resultArray) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no user returned from API")
        }</span>

        <span class="cov1" title="1">if resultArray[0].Error != "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user creation failed: %s", resultArray[0].Error)
        }</span>

        <span class="cov1" title="1">return &amp;resultArray[0].User, nil</span>
}

// UpdateUser updates an existing user
func (c *Client) UpdateUser(id string, user *User) (*User, error) <span class="cov1" title="1">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user ID is required")
        }</span>

        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user is required")
        }</span>

        <span class="cov1" title="1">path := fmt.Sprintf("users/%s", id)

        var result User
        err := c.Put(path, user, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user %s: %w", id, err)
        }</span>

        <span class="cov1" title="1">return &amp;result, nil</span>
}

// DeleteUser deletes a user
func (c *Client) DeleteUser(id string) error <span class="cov1" title="1">{
        if id == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("user ID is required")
        }</span>

        <span class="cov1" title="1">path := fmt.Sprintf("users/%s", id)

        err := c.Delete(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete user %s: %w", id, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>

		<pre class="file" id="file6" style="display: none">package client

import (
        "fmt"
        "net/url"
        "strconv"
        "time"
)

// Workflow represents an n8n workflow
type Workflow struct {
        ID          string                 `json:"id,omitempty"`
        Name        string                 `json:"name"`
        Active      bool                   `json:"active,omitempty"`
        Nodes       []interface{}          `json:"nodes,omitempty"`
        Connections map[string]interface{} `json:"connections"`
        Settings    map[string]interface{} `json:"settings,omitempty"`
        StaticData  map[string]interface{} `json:"staticData,omitempty"`
        PinnedData  map[string]interface{} `json:"pinnedData,omitempty"`
        Tags        []string               `json:"tags,omitempty"`
        VersionID   string                 `json:"versionId,omitempty"`
        CreatedAt   *time.Time             `json:"createdAt,omitempty"`
        UpdatedAt   *time.Time             `json:"updatedAt,omitempty"`
}

// WorkflowListOptions represents options for listing workflows
type WorkflowListOptions struct {
        Active    *bool
        Tags      []string
        ProjectID string
        Limit     int
        Offset    int
}

// WorkflowListResponse represents the response from listing workflows
type WorkflowListResponse struct {
        Data       []Workflow `json:"data"`
        NextCursor string     `json:"nextCursor,omitempty"`
}

// GetWorkflows retrieves a list of workflows
func (c *Client) GetWorkflows(options *WorkflowListOptions) (*WorkflowListResponse, error) <span class="cov6" title="2">{
        path := "workflows"

        if options != nil </span><span class="cov1" title="1">{
                params := url.Values{}

                if options.Active != nil </span><span class="cov1" title="1">{
                        params.Set("active", strconv.FormatBool(*options.Active))
                }</span>

                <span class="cov1" title="1">if len(options.Tags) &gt; 0 </span><span class="cov1" title="1">{
                        for _, tag := range options.Tags </span><span class="cov6" title="2">{
                                params.Add("tags", tag)
                        }</span>
                }

                <span class="cov1" title="1">if options.ProjectID != "" </span><span class="cov1" title="1">{
                        params.Set("projectId", options.ProjectID)
                }</span>

                <span class="cov1" title="1">if options.Limit &gt; 0 </span><span class="cov1" title="1">{
                        params.Set("limit", strconv.Itoa(options.Limit))
                }</span>

                <span class="cov1" title="1">if options.Offset &gt; 0 </span><span class="cov1" title="1">{
                        params.Set("offset", strconv.Itoa(options.Offset))
                }</span>

                <span class="cov1" title="1">if len(params) &gt; 0 </span><span class="cov1" title="1">{
                        path += "?" + params.Encode()
                }</span>
        }

        <span class="cov6" title="2">var result WorkflowListResponse
        err := c.Get(path, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get workflows: %w", err)
        }</span>

        <span class="cov6" title="2">return &amp;result, nil</span>
}

// GetWorkflow retrieves a specific workflow by ID
func (c *Client) GetWorkflow(id string) (*Workflow, error) <span class="cov6" title="2">{
        if id == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("workflow ID is required")
        }</span>

        <span class="cov1" title="1">path := fmt.Sprintf("workflows/%s", id)

        var workflow Workflow
        err := c.Get(path, &amp;workflow)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get workflow %s: %w", id, err)
        }</span>

        <span class="cov1" title="1">return &amp;workflow, nil</span>
}

// CreateWorkflow creates a new workflow
func (c *Client) CreateWorkflow(workflow *Workflow) (*Workflow, error) <span class="cov10" title="3">{
        if workflow == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("workflow is required")
        }</span>

        <span class="cov6" title="2">if workflow.Name == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("workflow name is required")
        }</span>

        <span class="cov1" title="1">var result Workflow
        err := c.Post("workflows", workflow, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create workflow: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;result, nil</span>
}

// UpdateWorkflow updates an existing workflow
func (c *Client) UpdateWorkflow(id string, workflow *Workflow) (*Workflow, error) <span class="cov10" title="3">{
        if id == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("workflow ID is required")
        }</span>

        <span class="cov6" title="2">if workflow == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("workflow is required")
        }</span>

        <span class="cov1" title="1">path := fmt.Sprintf("workflows/%s", id)

        var result Workflow
        err := c.Put(path, workflow, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update workflow %s: %w", id, err)
        }</span>

        <span class="cov1" title="1">return &amp;result, nil</span>
}

// DeleteWorkflow deletes a workflow
func (c *Client) DeleteWorkflow(id string) error <span class="cov6" title="2">{
        if id == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("workflow ID is required")
        }</span>

        <span class="cov1" title="1">path := fmt.Sprintf("workflows/%s", id)

        err := c.Delete(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete workflow %s: %w", id, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ActivateWorkflow activates a workflow
func (c *Client) ActivateWorkflow(id string) (*Workflow, error) <span class="cov6" title="2">{
        if id == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("workflow ID is required")
        }</span>

        <span class="cov1" title="1">path := fmt.Sprintf("workflows/%s/activate", id)

        var result Workflow
        err := c.Post(path, nil, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to activate workflow %s: %w", id, err)
        }</span>

        <span class="cov1" title="1">return &amp;result, nil</span>
}

// DeactivateWorkflow deactivates a workflow
func (c *Client) DeactivateWorkflow(id string) (*Workflow, error) <span class="cov6" title="2">{
        if id == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("workflow ID is required")
        }</span>

        <span class="cov1" title="1">path := fmt.Sprintf("workflows/%s/deactivate", id)

        var result Workflow
        err := c.Post(path, nil, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to deactivate workflow %s: %w", id, err)
        }</span>

        <span class="cov1" title="1">return &amp;result, nil</span>
}
</pre>

		<pre class="file" id="file7" style="display: none">package provider

import (
        "context"
        "encoding/json"
        "fmt"
        "slices"
        "strings"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"

        "github.com/devops247-online/terraform-provider-n8n/internal/client"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &amp;CredentialResource{}
var _ resource.ResourceWithImportState = &amp;CredentialResource{}

func NewCredentialResource() resource.Resource <span class="cov8" title="1">{
        return &amp;CredentialResource{}
}</span>

// CredentialResource defines the resource implementation.
type CredentialResource struct {
        client *client.Client
}

// CredentialResourceModel describes the resource data model.
type CredentialResourceModel struct {
        ID         types.String `tfsdk:"id"`
        Name       types.String `tfsdk:"name"`
        Type       types.String `tfsdk:"type"`
        Data       types.String `tfsdk:"data"`
        NodeAccess types.List   `tfsdk:"node_access"`
        CreatedAt  types.String `tfsdk:"created_at"`
        UpdatedAt  types.String `tfsdk:"updated_at"`
}

// Supported credential types for validation
var supportedCredentialTypes = []string{
        "httpBasicAuth",
        "apiKey",
        "oAuth2Api",
        "oAuth1Api",
        "googleOAuth2Api",
        "awsApi",
        "azureApi",
        "microsoftGraphApi",
        "httpDigestAuth",
        "httpHeaderAuth",
        "httpQueryAuth",
        "jwtAuth",
        "bearerTokenAuth",
        "samlAuth",
        "ldapAuth",
        "slackOAuth2Api",
        "githubOAuth2Api",
        "gitlabOAuth2Api",
        "discordOAuth2Api",
        "shopifyOAuth2Api",
        "stripeApi",
        "twilioApi",
        "sendGridApi",
        "mailgunApi",
        "dropboxOAuth2Api",
        "googleDriveOAuth2Api",
        "onedriveOAuth2Api",
        "boxOAuth2Api",
        "salesforceOAuth2Api",
        "hubspotOAuth2Api",
        "zendeskOAuth2Api",
        "jiraCloudApi",
        "confluenceCloudApi",
        "atlassianOAuth2Api",
        "trelloApi",
        "asanaOAuth2Api",
        "mondayComOAuth2Api",
        "notionOAuth2Api",
        "airtableOAuth2Api",
        "clickUpOAuth2Api",
        "linearOAuth2Api",
        "figmaOAuth2Api",
        "canvaOAuth2Api",
        "youtubeOAuth2Api",
        "spotifyOAuth2Api",
        "twitterOAuth2Api",
        "facebookGraphApi",
        "instagramGraphApi",
        "linkedInOAuth2Api",
        "telegramBotApi",
        "whatsappBusinessApi",
        "openAiApi",
        "anthropicApi",
        "huggingFaceApi",
        "cohereApi",
        "mistralApi",
        "groqApi",
}

func (r *CredentialResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_credential"
}</span>

func (r *CredentialResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Manages an n8n credential securely. Credentials store authentication information for services and APIs used by workflows, with proper handling of sensitive data.",

                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Credential identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "The name of the credential. Must be unique within the n8n instance.",
                                Required:            true,
                        },
                        "type": schema.StringAttribute{
                                MarkdownDescription: "The type of credential (e.g., 'httpBasicAuth', 'oAuth2Api', 'apiKey'). Determines the required data fields.",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "data": schema.StringAttribute{
                                MarkdownDescription: "JSON string containing the credential configuration data. This field is sensitive and will be encrypted in state.",
                                Optional:            true,
                                Sensitive:           true,
                        },
                        "node_access": schema.ListAttribute{
                                MarkdownDescription: "List of node names that can access this credential. If empty, all nodes can access it.",
                                ElementType:         types.StringType,
                                Optional:            true,
                        },
                        "created_at": schema.StringAttribute{
                                MarkdownDescription: "Timestamp when the credential was created",
                                Computed:            true,
                        },
                        "updated_at": schema.StringAttribute{
                                MarkdownDescription: "Timestamp when the credential was last updated",
                                Computed:            true,
                        },
                },
        }
}</span>

func (r *CredentialResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        // Prevent panic if the provider has not been configured.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, ok := req.ProviderData.(*client.Client)

        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )

                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *CredentialResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data CredentialResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Validate credential type
        <span class="cov0" title="0">if err := r.validateCredentialType(data.Type.ValueString()); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("type"),
                        "Invalid Credential Type",
                        err.Error(),
                )
                return
        }</span>

        // Create credential object
        <span class="cov0" title="0">credential := &amp;client.Credential{
                Name: data.Name.ValueString(),
                Type: data.Type.ValueString(),
        }

        // Data field is required by n8n API, default to empty object if not provided
        if !data.Data.IsNull() &amp;&amp; data.Data.ValueString() != "" </span><span class="cov0" title="0">{
                var credData map[string]interface{}
                if err := json.Unmarshal([]byte(data.Data.ValueString()), &amp;credData); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("data"),
                                "Invalid JSON",
                                fmt.Sprintf("Unable to parse credential data JSON: %s", err),
                        )
                        return
                }</span>

                // Validate credential data based on type
                <span class="cov0" title="0">if err := r.validateCredentialData(data.Type.ValueString(), credData); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("data"),
                                "Invalid Credential Data",
                                err.Error(),
                        )
                        return
                }</span>

                <span class="cov0" title="0">credential.Data = credData</span>
        } else<span class="cov0" title="0"> {
                // Set empty data object if not provided (required by n8n API)
                credential.Data = make(map[string]interface{})
        }</span>

        // Handle node access
        <span class="cov0" title="0">if !data.NodeAccess.IsNull() &amp;&amp; !data.NodeAccess.IsUnknown() </span><span class="cov0" title="0">{
                var nodeAccess []string
                resp.Diagnostics.Append(data.NodeAccess.ElementsAs(ctx, &amp;nodeAccess, false)...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">credential.SharedWith = nodeAccess</span>
        }

        // Create credential via API
        <span class="cov0" title="0">createdCredential, err := r.client.CreateCredential(credential)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create credential, got error: %s", err))
                return
        }</span>

        // Update model with response data
        <span class="cov0" title="0">r.updateModelFromCredential(&amp;data, createdCredential)

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *CredentialResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data CredentialResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get credential from API
        <span class="cov0" title="0">credential, err := r.client.GetCredential(data.ID.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read credential, got error: %s", err))
                return
        }</span>

        // Update model with response data
        <span class="cov0" title="0">r.updateModelFromCredential(&amp;data, credential)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *CredentialResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data CredentialResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Create credential object for update
        <span class="cov0" title="0">credential := &amp;client.Credential{
                Name: data.Name.ValueString(),
                Type: data.Type.ValueString(),
        }

        // Data field is required by n8n API, default to empty object if not provided
        if !data.Data.IsNull() &amp;&amp; data.Data.ValueString() != "" </span><span class="cov0" title="0">{
                var credData map[string]interface{}
                if err := json.Unmarshal([]byte(data.Data.ValueString()), &amp;credData); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("data"),
                                "Invalid JSON",
                                fmt.Sprintf("Unable to parse credential data JSON: %s", err),
                        )
                        return
                }</span>

                // Validate credential data based on type
                <span class="cov0" title="0">if err := r.validateCredentialData(data.Type.ValueString(), credData); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("data"),
                                "Invalid Credential Data",
                                err.Error(),
                        )
                        return
                }</span>

                <span class="cov0" title="0">credential.Data = credData</span>
        } else<span class="cov0" title="0"> {
                // Set empty data object if not provided (required by n8n API)
                credential.Data = make(map[string]interface{})
        }</span>

        // Handle node access
        <span class="cov0" title="0">if !data.NodeAccess.IsNull() &amp;&amp; !data.NodeAccess.IsUnknown() </span><span class="cov0" title="0">{
                var nodeAccess []string
                resp.Diagnostics.Append(data.NodeAccess.ElementsAs(ctx, &amp;nodeAccess, false)...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">credential.SharedWith = nodeAccess</span>
        }

        // Update credential via API
        <span class="cov0" title="0">updatedCredential, err := r.client.UpdateCredential(data.ID.ValueString(), credential)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update credential, got error: %s", err))
                return
        }</span>

        // Update model with response data
        <span class="cov0" title="0">r.updateModelFromCredential(&amp;data, updatedCredential)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *CredentialResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data CredentialResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Delete credential via API
        <span class="cov0" title="0">err := r.client.DeleteCredential(data.ID.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete credential, got error: %s", err))
                return
        }</span>
}

func (r *CredentialResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>

// validateCredentialType validates that the credential type is supported
func (r *CredentialResource) validateCredentialType(credType string) error <span class="cov0" title="0">{
        if credType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("credential type is required")
        }</span>

        <span class="cov0" title="0">if !slices.Contains(supportedCredentialTypes, credType) </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported credential type: %s. Supported types: %s", credType, strings.Join(supportedCredentialTypes, ", "))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateCredentialData validates the credential data based on type
func (r *CredentialResource) validateCredentialData(credType string, data map[string]interface{}) error <span class="cov0" title="0">{
        if data == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Type-specific validation
        <span class="cov0" title="0">switch credType </span>{
        case "httpBasicAuth":<span class="cov0" title="0">
                if _, hasUser := data["user"]; !hasUser </span><span class="cov0" title="0">{
                        return fmt.Errorf("httpBasicAuth credential requires 'user' field")
                }</span>
                <span class="cov0" title="0">if _, hasPassword := data["password"]; !hasPassword </span><span class="cov0" title="0">{
                        return fmt.Errorf("httpBasicAuth credential requires 'password' field")
                }</span>

        case "apiKey":<span class="cov0" title="0">
                if _, hasApiKey := data["apiKey"]; !hasApiKey </span><span class="cov0" title="0">{
                        return fmt.Errorf("apiKey credential requires 'apiKey' field")
                }</span>

        case "oAuth2Api":<span class="cov0" title="0">
                if _, hasClientId := data["clientId"]; !hasClientId </span><span class="cov0" title="0">{
                        return fmt.Errorf("oAuth2Api credential requires 'clientId' field")
                }</span>
                <span class="cov0" title="0">if _, hasClientSecret := data["clientSecret"]; !hasClientSecret </span><span class="cov0" title="0">{
                        return fmt.Errorf("oAuth2Api credential requires 'clientSecret' field")
                }</span>

        case "bearerTokenAuth":<span class="cov0" title="0">
                if _, hasToken := data["token"]; !hasToken </span><span class="cov0" title="0">{
                        return fmt.Errorf("bearerTokenAuth credential requires 'token' field")
                }</span>

        case "httpHeaderAuth":<span class="cov0" title="0">
                if _, hasName := data["name"]; !hasName </span><span class="cov0" title="0">{
                        return fmt.Errorf("httpHeaderAuth credential requires 'name' field")
                }</span>
                <span class="cov0" title="0">if _, hasValue := data["value"]; !hasValue </span><span class="cov0" title="0">{
                        return fmt.Errorf("httpHeaderAuth credential requires 'value' field")
                }</span>

        case "awsApi":<span class="cov0" title="0">
                if _, hasAccessKeyId := data["accessKeyId"]; !hasAccessKeyId </span><span class="cov0" title="0">{
                        return fmt.Errorf("awsApi credential requires 'accessKeyId' field")
                }</span>
                <span class="cov0" title="0">if _, hasSecretAccessKey := data["secretAccessKey"]; !hasSecretAccessKey </span><span class="cov0" title="0">{
                        return fmt.Errorf("awsApi credential requires 'secretAccessKey' field")
                }</span>

        case "googleOAuth2Api":<span class="cov0" title="0">
                if _, hasClientId := data["clientId"]; !hasClientId </span><span class="cov0" title="0">{
                        return fmt.Errorf("googleOAuth2Api credential requires 'clientId' field")
                }</span>
                <span class="cov0" title="0">if _, hasClientSecret := data["clientSecret"]; !hasClientSecret </span><span class="cov0" title="0">{
                        return fmt.Errorf("googleOAuth2Api credential requires 'clientSecret' field")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper function to update model from API response
func (r *CredentialResource) updateModelFromCredential(model *CredentialResourceModel, credential *client.Credential) <span class="cov0" title="0">{
        model.ID = types.StringValue(credential.ID)
        model.Name = types.StringValue(credential.Name)
        model.Type = types.StringValue(credential.Type)

        // Convert credential data to JSON string (but keep it sensitive)
        // Note: We don't include sensitive data in read operations for security
        if len(credential.Data) &gt; 0 </span><span class="cov0" title="0">{
                // Only update data field if it's currently set (to preserve sensitive data in state)
                if !model.Data.IsNull() </span><span class="cov0" title="0">{
                        if dataJSON, err := json.Marshal(credential.Data); err == nil </span><span class="cov0" title="0">{
                                model.Data = types.StringValue(string(dataJSON))
                        }</span>
                }
        }

        // Handle node access / shared with
        <span class="cov0" title="0">if len(credential.SharedWith) &gt; 0 </span><span class="cov0" title="0">{
                nodeAccessValues := make([]attr.Value, len(credential.SharedWith))
                for i, node := range credential.SharedWith </span><span class="cov0" title="0">{
                        nodeAccessValues[i] = types.StringValue(node)
                }</span>
                <span class="cov0" title="0">model.NodeAccess = types.ListValueMust(types.StringType, nodeAccessValues)</span>
        } else<span class="cov0" title="0"> {
                // Set as null List when no shared access is configured
                model.NodeAccess = types.ListNull(types.StringType)
        }</span>

        <span class="cov0" title="0">if credential.CreatedAt != nil </span><span class="cov0" title="0">{
                model.CreatedAt = types.StringValue(credential.CreatedAt.Format("2006-01-02T15:04:05Z"))
        }</span>

        <span class="cov0" title="0">if credential.UpdatedAt != nil </span><span class="cov0" title="0">{
                model.UpdatedAt = types.StringValue(credential.UpdatedAt.Format("2006-01-02T15:04:05Z"))
        }</span>
}
</pre>

		<pre class="file" id="file8" style="display: none">package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"

        "github.com/devops247-online/terraform-provider-n8n/internal/client"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &amp;LDAPConfigResource{}
var _ resource.ResourceWithImportState = &amp;LDAPConfigResource{}

func NewLDAPConfigResource() resource.Resource <span class="cov8" title="1">{
        return &amp;LDAPConfigResource{}
}</span>

// LDAPConfigResource defines the resource implementation.
type LDAPConfigResource struct {
        client *client.Client
}

// LDAPConfigResourceModel describes the resource data model.
type LDAPConfigResourceModel struct {
        ID                     types.String `tfsdk:"id"`
        ServerURL              types.String `tfsdk:"server_url"`
        BindDN                 types.String `tfsdk:"bind_dn"`
        BindPassword           types.String `tfsdk:"bind_password"`
        SearchBase             types.String `tfsdk:"search_base"`
        SearchFilter           types.String `tfsdk:"search_filter"`
        UserIDAttribute        types.String `tfsdk:"user_id_attribute"`
        UserEmailAttribute     types.String `tfsdk:"user_email_attribute"`
        UserFirstNameAttribute types.String `tfsdk:"user_first_name_attribute"`
        UserLastNameAttribute  types.String `tfsdk:"user_last_name_attribute"`
        GroupSearchBase        types.String `tfsdk:"group_search_base"`
        GroupSearchFilter      types.String `tfsdk:"group_search_filter"`
        TLSEnabled             types.Bool   `tfsdk:"tls_enabled"`
        CACertificate          types.String `tfsdk:"ca_certificate"`
}

func (r *LDAPConfigResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_ldap_config"
}</span>

func (r *LDAPConfigResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Manages LDAP configuration for n8n Enterprise. This resource configures LDAP authentication and user synchronization.",

                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "LDAP configuration identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "server_url": schema.StringAttribute{
                                MarkdownDescription: "LDAP server URL (e.g., ldap://ldap.example.com:389 or ldaps://ldap.example.com:636)",
                                Required:            true,
                        },
                        "bind_dn": schema.StringAttribute{
                                MarkdownDescription: "Bind DN for LDAP connection (e.g., cn=admin,dc=example,dc=com)",
                                Required:            true,
                        },
                        "bind_password": schema.StringAttribute{
                                MarkdownDescription: "Bind password for LDAP connection",
                                Required:            true,
                                Sensitive:           true,
                        },
                        "search_base": schema.StringAttribute{
                                MarkdownDescription: "User search base DN (e.g., ou=users,dc=example,dc=com)",
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString(""),
                        },
                        "search_filter": schema.StringAttribute{
                                MarkdownDescription: "User search filter (e.g., (uid={{username}}))",
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("(uid={{username}})"),
                        },
                        "user_id_attribute": schema.StringAttribute{
                                MarkdownDescription: "Attribute for user ID",
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("uid"),
                        },
                        "user_email_attribute": schema.StringAttribute{
                                MarkdownDescription: "Attribute for user email",
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("mail"),
                        },
                        "user_first_name_attribute": schema.StringAttribute{
                                MarkdownDescription: "Attribute for user first name",
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("givenName"),
                        },
                        "user_last_name_attribute": schema.StringAttribute{
                                MarkdownDescription: "Attribute for user last name",
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("sn"),
                        },
                        "group_search_base": schema.StringAttribute{
                                MarkdownDescription: "Group search base DN (e.g., ou=groups,dc=example,dc=com)",
                                Optional:            true,
                        },
                        "group_search_filter": schema.StringAttribute{
                                MarkdownDescription: "Group search filter (e.g., (member={{userDN}}))",
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("(member={{userDN}})"),
                        },
                        "tls_enabled": schema.BoolAttribute{
                                MarkdownDescription: "Enable TLS connection",
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                        },
                        "ca_certificate": schema.StringAttribute{
                                MarkdownDescription: "CA certificate for TLS connection (PEM format)",
                                Optional:            true,
                                Sensitive:           true,
                        },
                },
        }
}</span>

func (r *LDAPConfigResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        // Prevent panic if the provider has not been configured.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, ok := req.ProviderData.(*client.Client)

        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )

                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *LDAPConfigResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data LDAPConfigResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Create LDAP config object
        <span class="cov0" title="0">config := &amp;client.LDAPConfig{
                ServerURL:              data.ServerURL.ValueString(),
                BindDN:                 data.BindDN.ValueString(),
                BindPassword:           data.BindPassword.ValueString(),
                SearchBase:             data.SearchBase.ValueString(),
                SearchFilter:           data.SearchFilter.ValueString(),
                UserIDAttribute:        data.UserIDAttribute.ValueString(),
                UserEmailAttribute:     data.UserEmailAttribute.ValueString(),
                UserFirstNameAttribute: data.UserFirstNameAttribute.ValueString(),
                UserLastNameAttribute:  data.UserLastNameAttribute.ValueString(),
                GroupSearchBase:        data.GroupSearchBase.ValueString(),
                GroupSearchFilter:      data.GroupSearchFilter.ValueString(),
                TLSEnabled:             data.TLSEnabled.ValueBool(),
                CACertificate:          data.CACertificate.ValueString(),
        }

        // Update LDAP config via API (LDAP config is a singleton, so we use update)
        updatedConfig, err := r.client.UpdateLDAPConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create LDAP config, got error: %s", err))
                return
        }</span>

        // Update model with response data
        <span class="cov0" title="0">r.updateModelFromLDAPConfig(&amp;data, updatedConfig)

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *LDAPConfigResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data LDAPConfigResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get LDAP config from API
        <span class="cov0" title="0">config, err := r.client.GetLDAPConfig()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read LDAP config, got error: %s", err))
                return
        }</span>

        // Update model with response data
        <span class="cov0" title="0">r.updateModelFromLDAPConfig(&amp;data, config)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *LDAPConfigResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data LDAPConfigResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Create LDAP config object for update
        <span class="cov0" title="0">config := &amp;client.LDAPConfig{
                ServerURL:              data.ServerURL.ValueString(),
                BindDN:                 data.BindDN.ValueString(),
                BindPassword:           data.BindPassword.ValueString(),
                SearchBase:             data.SearchBase.ValueString(),
                SearchFilter:           data.SearchFilter.ValueString(),
                UserIDAttribute:        data.UserIDAttribute.ValueString(),
                UserEmailAttribute:     data.UserEmailAttribute.ValueString(),
                UserFirstNameAttribute: data.UserFirstNameAttribute.ValueString(),
                UserLastNameAttribute:  data.UserLastNameAttribute.ValueString(),
                GroupSearchBase:        data.GroupSearchBase.ValueString(),
                GroupSearchFilter:      data.GroupSearchFilter.ValueString(),
                TLSEnabled:             data.TLSEnabled.ValueBool(),
                CACertificate:          data.CACertificate.ValueString(),
        }

        // Update LDAP config via API
        updatedConfig, err := r.client.UpdateLDAPConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update LDAP config, got error: %s", err))
                return
        }</span>

        // Update model with response data
        <span class="cov0" title="0">r.updateModelFromLDAPConfig(&amp;data, updatedConfig)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *LDAPConfigResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        // LDAP config cannot be deleted, only disabled
        // We could potentially clear the configuration by setting minimal values
        resp.Diagnostics.AddWarning(
                "LDAP Configuration Not Deleted",
                "LDAP configuration cannot be deleted from n8n. The resource has been removed from Terraform state, but the LDAP configuration remains in n8n. To disable LDAP, update the configuration with appropriate values.",
        )
}</span>

func (r *LDAPConfigResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        // LDAP config is a singleton, so we use a fixed ID
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), "ldap")...)
}</span>

// Helper function to update model from API response
func (r *LDAPConfigResource) updateModelFromLDAPConfig(model *LDAPConfigResourceModel, config *client.LDAPConfig) <span class="cov0" title="0">{
        model.ID = types.StringValue("ldap") // LDAP config is a singleton
        model.ServerURL = types.StringValue(config.ServerURL)
        model.BindDN = types.StringValue(config.BindDN)
        // Don't update bind_password from response for security
        model.SearchBase = types.StringValue(config.SearchBase)
        model.SearchFilter = types.StringValue(config.SearchFilter)
        model.UserIDAttribute = types.StringValue(config.UserIDAttribute)
        model.UserEmailAttribute = types.StringValue(config.UserEmailAttribute)
        model.UserFirstNameAttribute = types.StringValue(config.UserFirstNameAttribute)
        model.UserLastNameAttribute = types.StringValue(config.UserLastNameAttribute)
        model.GroupSearchBase = types.StringValue(config.GroupSearchBase)
        model.GroupSearchFilter = types.StringValue(config.GroupSearchFilter)
        model.TLSEnabled = types.BoolValue(config.TLSEnabled)
        // Don't update ca_certificate from response for security
}</span>
</pre>

		<pre class="file" id="file9" style="display: none">package provider

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"

        "github.com/devops247-online/terraform-provider-n8n/internal/client"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &amp;ProjectResource{}
var _ resource.ResourceWithImportState = &amp;ProjectResource{}

func NewProjectResource() resource.Resource <span class="cov8" title="1">{
        return &amp;ProjectResource{}
}</span>

// ProjectResource defines the resource implementation.
type ProjectResource struct {
        client *client.Client
}

// ProjectResourceModel describes the resource data model.
type ProjectResourceModel struct {
        ID          types.String `tfsdk:"id"`
        Name        types.String `tfsdk:"name"`
        Description types.String `tfsdk:"description"`
        Settings    types.String `tfsdk:"settings"`
        Icon        types.String `tfsdk:"icon"`
        Color       types.String `tfsdk:"color"`
        OwnerID     types.String `tfsdk:"owner_id"`
        MemberCount types.Int64  `tfsdk:"member_count"`
        CreatedAt   types.String `tfsdk:"created_at"`
        UpdatedAt   types.String `tfsdk:"updated_at"`
}

func (r *ProjectResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_project"
}</span>

func (r *ProjectResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Manages an n8n project. Projects provide workspace isolation and team collaboration features in n8n Enterprise.",

                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Project identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "The name of the project",
                                Required:            true,
                        },
                        "description": schema.StringAttribute{
                                MarkdownDescription: "The description of the project",
                                Optional:            true,
                        },
                        "settings": schema.StringAttribute{
                                MarkdownDescription: "JSON string containing project-specific settings",
                                Optional:            true,
                                Computed:            true,
                        },
                        "icon": schema.StringAttribute{
                                MarkdownDescription: "Project icon identifier",
                                Optional:            true,
                        },
                        "color": schema.StringAttribute{
                                MarkdownDescription: "Project color scheme",
                                Optional:            true,
                        },
                        "owner_id": schema.StringAttribute{
                                MarkdownDescription: "Project owner user ID",
                                Computed:            true,
                        },
                        "member_count": schema.Int64Attribute{
                                MarkdownDescription: "Number of project members",
                                Computed:            true,
                        },
                        "created_at": schema.StringAttribute{
                                MarkdownDescription: "Timestamp when the project was created",
                                Computed:            true,
                        },
                        "updated_at": schema.StringAttribute{
                                MarkdownDescription: "Timestamp when the project was last updated",
                                Computed:            true,
                        },
                },
        }
}</span>

func (r *ProjectResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        // Prevent panic if the provider has not been configured.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, ok := req.ProviderData.(*client.Client)

        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )

                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *ProjectResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data ProjectResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Create project object
        <span class="cov0" title="0">project := &amp;client.Project{
                Name:        data.Name.ValueString(),
                Description: data.Description.ValueString(),
                Icon:        data.Icon.ValueString(),
                Color:       data.Color.ValueString(),
        }

        // Parse and validate settings JSON if provided
        if !data.Settings.IsNull() &amp;&amp; data.Settings.ValueString() != "" </span><span class="cov0" title="0">{
                var settings map[string]interface{}
                if err := json.Unmarshal([]byte(data.Settings.ValueString()), &amp;settings); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("settings"),
                                "Invalid JSON",
                                fmt.Sprintf("Unable to parse settings JSON: %s", err),
                        )
                        return
                }</span>
                <span class="cov0" title="0">project.Settings = settings</span>
        }

        // Create project via API
        <span class="cov0" title="0">createdProject, err := r.client.CreateProject(project)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create project, got error: %s", err))
                return
        }</span>

        // Update model with response data
        <span class="cov0" title="0">r.updateModelFromProject(&amp;data, createdProject)

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ProjectResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data ProjectResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get project from API
        <span class="cov0" title="0">project, err := r.client.GetProject(data.ID.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read project, got error: %s", err))
                return
        }</span>

        // Update model with response data
        <span class="cov0" title="0">r.updateModelFromProject(&amp;data, project)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ProjectResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data ProjectResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Create project object for update
        <span class="cov0" title="0">project := &amp;client.Project{
                Name:        data.Name.ValueString(),
                Description: data.Description.ValueString(),
                Icon:        data.Icon.ValueString(),
                Color:       data.Color.ValueString(),
        }

        // Parse and validate settings JSON if provided
        if !data.Settings.IsNull() &amp;&amp; data.Settings.ValueString() != "" </span><span class="cov0" title="0">{
                var settings map[string]interface{}
                if err := json.Unmarshal([]byte(data.Settings.ValueString()), &amp;settings); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("settings"),
                                "Invalid JSON",
                                fmt.Sprintf("Unable to parse settings JSON: %s", err),
                        )
                        return
                }</span>
                <span class="cov0" title="0">project.Settings = settings</span>
        }

        // Update project via API
        <span class="cov0" title="0">updatedProject, err := r.client.UpdateProject(data.ID.ValueString(), project)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update project, got error: %s", err))
                return
        }</span>

        // Update model with response data
        <span class="cov0" title="0">r.updateModelFromProject(&amp;data, updatedProject)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ProjectResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data ProjectResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Delete project via API
        <span class="cov0" title="0">err := r.client.DeleteProject(data.ID.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete project, got error: %s", err))
                return
        }</span>
}

func (r *ProjectResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>

// Helper function to update model from API response
func (r *ProjectResource) updateModelFromProject(model *ProjectResourceModel, project *client.Project) <span class="cov0" title="0">{
        model.ID = types.StringValue(project.ID)
        model.Name = types.StringValue(project.Name)
        model.Description = types.StringValue(project.Description)
        model.Icon = types.StringValue(project.Icon)
        model.Color = types.StringValue(project.Color)
        model.OwnerID = types.StringValue(project.OwnerID)
        model.MemberCount = types.Int64Value(int64(project.MemberCount))

        // Convert settings to JSON string
        if project.Settings != nil </span><span class="cov0" title="0">{
                if settingsJSON, err := json.Marshal(project.Settings); err == nil </span><span class="cov0" title="0">{
                        model.Settings = types.StringValue(string(settingsJSON))
                }</span>
        }

        <span class="cov0" title="0">if project.CreatedAt != nil </span><span class="cov0" title="0">{
                model.CreatedAt = types.StringValue(project.CreatedAt.Format("2006-01-02T15:04:05Z"))
        }</span>

        <span class="cov0" title="0">if project.UpdatedAt != nil </span><span class="cov0" title="0">{
                model.UpdatedAt = types.StringValue(project.UpdatedAt.Format("2006-01-02T15:04:05Z"))
        }</span>
}
</pre>

		<pre class="file" id="file10" style="display: none">package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"

        "github.com/devops247-online/terraform-provider-n8n/internal/client"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &amp;ProjectUserResource{}
var _ resource.ResourceWithImportState = &amp;ProjectUserResource{}

func NewProjectUserResource() resource.Resource <span class="cov8" title="1">{
        return &amp;ProjectUserResource{}
}</span>

// ProjectUserResource defines the resource implementation.
type ProjectUserResource struct {
        client *client.Client
}

// ProjectUserResourceModel describes the resource data model.
type ProjectUserResourceModel struct {
        ID        types.String `tfsdk:"id"`
        ProjectID types.String `tfsdk:"project_id"`
        UserID    types.String `tfsdk:"user_id"`
        Role      types.String `tfsdk:"role"`
        AddedAt   types.String `tfsdk:"added_at"`
}

func (r *ProjectUserResource) Metadata(ctx context.Context, req resource.MetadataRequest,
        resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_project_user"
}</span>

func (r *ProjectUserResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Manages user membership in an n8n project. This resource allows you to " +
                        "assign users to projects with specific roles.",

                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Project user assignment identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "The ID of the project",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "user_id": schema.StringAttribute{
                                MarkdownDescription: "The ID or email of the user to add to the project",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "role": schema.StringAttribute{
                                MarkdownDescription: "The role of the user in the project (admin, editor, viewer)",
                                Optional:            true,
                                Computed:            true,
                                Default:             stringdefault.StaticString("viewer"),
                        },
                        "added_at": schema.StringAttribute{
                                MarkdownDescription: "Timestamp when the user was added to the project",
                                Computed:            true,
                        },
                },
        }
}</span>

func (r *ProjectUserResource) Configure(ctx context.Context, req resource.ConfigureRequest,
        resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        // Prevent panic if the provider has not been configured.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, ok := req.ProviderData.(*client.Client)

        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.",
                                req.ProviderData),
                )

                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *ProjectUserResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data ProjectUserResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Create project user object
        <span class="cov0" title="0">projectUser := &amp;client.ProjectUser{
                ProjectID: data.ProjectID.ValueString(),
                UserID:    data.UserID.ValueString(),
                Role:      data.Role.ValueString(),
        }

        // Add user to project via API
        createdProjectUser, err := r.client.AddUserToProject(projectUser)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to add user to project, got error: %s", err))
                return
        }</span>

        // Update model with response data
        <span class="cov0" title="0">r.updateModelFromProjectUser(&amp;data, createdProjectUser)

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ProjectUserResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data ProjectUserResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get project users from API
        <span class="cov0" title="0">projectUsers, err := r.client.GetProjectUsers(data.ProjectID.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read project users, got error: %s", err))
                return
        }</span>

        // Find the specific user
        <span class="cov0" title="0">var foundUser *client.ProjectUser
        for _, user := range projectUsers </span><span class="cov0" title="0">{
                if user.UserID == data.UserID.ValueString() </span><span class="cov0" title="0">{
                        foundUser = &amp;user
                        break</span>
                }
        }

        <span class="cov0" title="0">if foundUser == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Not Found",
                        fmt.Sprintf("User %s not found in project %s", data.UserID.ValueString(), data.ProjectID.ValueString()))
                return
        }</span>

        // Update model with response data
        <span class="cov0" title="0">r.updateModelFromProjectUser(&amp;data, foundUser)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ProjectUserResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data ProjectUserResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Create project user object for update
        <span class="cov0" title="0">projectUser := &amp;client.ProjectUser{
                ProjectID: data.ProjectID.ValueString(),
                UserID:    data.UserID.ValueString(),
                Role:      data.Role.ValueString(),
        }

        // Update project user via API
        updatedProjectUser, err := r.client.UpdateProjectUser(data.ProjectID.ValueString(),
                data.UserID.ValueString(), projectUser)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update project user, got error: %s", err))
                return
        }</span>

        // Update model with response data
        <span class="cov0" title="0">r.updateModelFromProjectUser(&amp;data, updatedProjectUser)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ProjectUserResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data ProjectUserResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Remove user from project via API
        <span class="cov0" title="0">err := r.client.RemoveUserFromProject(data.ProjectID.ValueString(), data.UserID.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to remove user from project, got error: %s", err))
                return
        }</span>
}

func (r *ProjectUserResource) ImportState(ctx context.Context, req resource.ImportStateRequest,
        resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        // Import state should be in the format "project_id:user_id"
        // We'll parse this in the ID field and then set the individual fields
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>

// Helper function to update model from API response
func (r *ProjectUserResource) updateModelFromProjectUser(model *ProjectUserResourceModel,
        projectUser *client.ProjectUser) <span class="cov0" title="0">{
        model.ID = types.StringValue(fmt.Sprintf("%s:%s", projectUser.ProjectID, projectUser.UserID))
        model.ProjectID = types.StringValue(projectUser.ProjectID)
        model.UserID = types.StringValue(projectUser.UserID)
        model.Role = types.StringValue(projectUser.Role)

        if projectUser.AddedAt != nil </span><span class="cov0" title="0">{
                model.AddedAt = types.StringValue(projectUser.AddedAt.Format("2006-01-02T15:04:05Z"))
        }</span>
}
</pre>

		<pre class="file" id="file11" style="display: none">package provider

import (
        "context"
        "os"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/function"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/provider"
        "github.com/hashicorp/terraform-plugin-framework/provider/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/types"

        "github.com/devops247-online/terraform-provider-n8n/internal/client"
)

// Ensure N8nProvider satisfies various provider interfaces.
var _ provider.Provider = &amp;N8nProvider{}
var _ provider.ProviderWithFunctions = &amp;N8nProvider{}

// N8nProvider defines the provider implementation.
type N8nProvider struct {
        // version is set to the provider version on release, "dev" when the
        // provider is built and ran locally, and "test" when running acceptance
        // testing.
        version string
}

// N8nProviderModel describes the provider data model.
type N8nProviderModel struct {
        BaseURL            types.String `tfsdk:"base_url"`
        APIKey             types.String `tfsdk:"api_key"`
        Email              types.String `tfsdk:"email"`
        Password           types.String `tfsdk:"password"`
        InsecureSkipVerify types.Bool   `tfsdk:"insecure_skip_verify"`
}

func (p *N8nProvider) Metadata(ctx context.Context, req provider.MetadataRequest, resp *provider.MetadataResponse) <span class="cov1" title="1">{
        resp.TypeName = "n8n"
        resp.Version = p.version
}</span>

func (p *N8nProvider) Schema(ctx context.Context, req provider.SchemaRequest, resp *provider.SchemaResponse) <span class="cov1" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "The n8n provider allows you to manage n8n workflows, credentials, and other resources " +
                        "using Infrastructure as Code.\n\n" +
                        "n8n is a free and source-available workflow automation tool that lets you connect anything to " +
                        "everything via its open, fair-code model.",
                Attributes: map[string]schema.Attribute{
                        "base_url": schema.StringAttribute{
                                MarkdownDescription: "The base URL of your n8n instance. Can be set via the " +
                                        "`N8N_BASE_URL` environment variable.",
                                Optional: true,
                        },
                        "api_key": schema.StringAttribute{
                                MarkdownDescription: "API key for authentication with n8n. Can be set via the " +
                                        "`N8N_API_KEY` environment variable.",
                                Optional:  true,
                                Sensitive: true,
                        },
                        "email": schema.StringAttribute{
                                MarkdownDescription: "Email for basic authentication with n8n. Can be set via the " +
                                        "`N8N_EMAIL` environment variable. Alternative to api_key.",
                                Optional: true,
                        },
                        "password": schema.StringAttribute{
                                MarkdownDescription: "Password for basic authentication with n8n. Can be set via the " +
                                        "`N8N_PASSWORD` environment variable. Alternative to api_key.",
                                Optional:  true,
                                Sensitive: true,
                        },
                        "insecure_skip_verify": schema.BoolAttribute{
                                MarkdownDescription: "Skip TLS certificate verification. Can be set via the " +
                                        "`N8N_INSECURE_SKIP_VERIFY` environment variable. Defaults to false.",
                                Optional: true,
                        },
                },
        }
}</span>

func (p *N8nProvider) Configure(ctx context.Context, req provider.ConfigureRequest, resp *provider.ConfigureResponse) <span class="cov0" title="0">{
        var data N8nProviderModel

        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Configuration values
        <span class="cov0" title="0">baseURL := os.Getenv("N8N_BASE_URL")
        apiKey := os.Getenv("N8N_API_KEY")
        email := os.Getenv("N8N_EMAIL")
        password := os.Getenv("N8N_PASSWORD")
        insecureSkipVerify := os.Getenv("N8N_INSECURE_SKIP_VERIFY") == "true"

        if !data.BaseURL.IsNull() </span><span class="cov0" title="0">{
                baseURL = data.BaseURL.ValueString()
        }</span>

        <span class="cov0" title="0">if !data.APIKey.IsNull() </span><span class="cov0" title="0">{
                apiKey = data.APIKey.ValueString()
        }</span>

        <span class="cov0" title="0">if !data.Email.IsNull() </span><span class="cov0" title="0">{
                email = data.Email.ValueString()
        }</span>

        <span class="cov0" title="0">if !data.Password.IsNull() </span><span class="cov0" title="0">{
                password = data.Password.ValueString()
        }</span>

        <span class="cov0" title="0">if !data.InsecureSkipVerify.IsNull() </span><span class="cov0" title="0">{
                insecureSkipVerify = data.InsecureSkipVerify.ValueBool()
        }</span>

        // If practitioner-provided configuration is missing, add errors.
        <span class="cov0" title="0">if baseURL == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("base_url"),
                        "Missing n8n Base URL",
                        "The provider cannot create the n8n API client as there is a missing or empty value for the n8n base URL. "+
                                "Set the base_url attribute in the provider configuration or use the N8N_BASE_URL environment variable. "+
                                "If either is already set, ensure the value is not empty.",
                )
        }</span>

        // Check for session-based authentication from CI environment
        <span class="cov0" title="0">useSessionAuth := os.Getenv("N8N_USE_SESSION_AUTH") == "true"
        cookieFile := os.Getenv("N8N_COOKIE_FILE")

        // Create n8n client with appropriate authentication method
        var authMethod client.AuthMethod

        if useSessionAuth &amp;&amp; cookieFile != "" </span><span class="cov0" title="0">{
                // Use session-based authentication for CI environments
                authMethod = &amp;client.SessionAuth{
                        CookieFile: cookieFile,
                }
        }</span> else<span class="cov0" title="0"> if apiKey != "" </span><span class="cov0" title="0">{
                authMethod = &amp;client.APIKeyAuth{APIKey: apiKey}
        }</span> else<span class="cov0" title="0"> if email != "" &amp;&amp; password != "" </span><span class="cov0" title="0">{
                authMethod = &amp;client.BasicAuth{Email: email, Password: password}
        }</span> else<span class="cov0" title="0"> {
                resp.Diagnostics.AddAttributeError(
                        path.Root("api_key"),
                        "Missing n8n Authentication",
                        "The provider cannot create the n8n API client as there is missing authentication information. "+
                                "Either set the api_key attribute in the provider configuration or use the N8N_API_KEY environment variable, "+
                                "or provide both email and password for basic authentication via the N8N_EMAIL and N8N_PASSWORD environment variables.",
                )
                return
        }</span>

        <span class="cov0" title="0">clientConfig := &amp;client.Config{
                BaseURL:            baseURL,
                Auth:               authMethod,
                InsecureSkipVerify: insecureSkipVerify,
        }

        n8nClient, err := client.NewClient(clientConfig)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Create n8n API Client",
                        "An unexpected error occurred when creating the n8n API client. "+
                                "If the error is not clear, please contact the provider developers.\n\n"+
                                "n8n Client Error: "+err.Error(),
                )
                return
        }</span>

        // Make the n8n client available during DataSource and Resource
        // type Configure methods.
        <span class="cov0" title="0">resp.DataSourceData = n8nClient
        resp.ResourceData = n8nClient</span>
}

func (p *N8nProvider) Resources(ctx context.Context) []func() resource.Resource <span class="cov1" title="1">{
        return []func() resource.Resource{
                NewWorkflowResource,
                NewCredentialResource,
                NewUserResource,
                NewProjectResource,
                NewProjectUserResource,
                NewLDAPConfigResource,
        }
}</span>

func (p *N8nProvider) DataSources(ctx context.Context) []func() datasource.DataSource <span class="cov1" title="1">{
        return []func() datasource.DataSource{
                NewUserDataSource,
        }
}</span>

func (p *N8nProvider) Functions(ctx context.Context) []func() function.Function <span class="cov1" title="1">{
        return []func() function.Function{
                // Functions will be added here if needed
        }
}</span>

func New(version string) func() provider.Provider <span class="cov10" title="5">{
        return func() provider.Provider </span><span class="cov10" title="5">{
                return &amp;N8nProvider{
                        version: version,
                }
        }</span>
}
</pre>

		<pre class="file" id="file12" style="display: none">package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"

        "github.com/devops247-online/terraform-provider-n8n/internal/client"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ datasource.DataSource = &amp;UserDataSource{}

func NewUserDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;UserDataSource{}
}</span>

// UserDataSource defines the data source implementation.
type UserDataSource struct {
        client *client.Client
}

// UserDataSourceModel describes the data source data model.
type UserDataSourceModel struct {
        ID        types.String `tfsdk:"id"`
        Email     types.String `tfsdk:"email"`
        FirstName types.String `tfsdk:"first_name"`
        LastName  types.String `tfsdk:"last_name"`
        Role      types.String `tfsdk:"role"`
        IsOwner   types.Bool   `tfsdk:"is_owner"`
        IsPending types.Bool   `tfsdk:"is_pending"`
        Settings  types.Object `tfsdk:"settings"`
        CreatedAt types.String `tfsdk:"created_at"`
        UpdatedAt types.String `tfsdk:"updated_at"`
}

func (d *UserDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest,
        resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_user"
}</span>

func (d *UserDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Fetches information about an n8n user. You can look up a user by their ID or email address.",

                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "User identifier. Either id or email must be provided.",
                                Optional:            true,
                                Computed:            true,
                        },
                        "email": schema.StringAttribute{
                                MarkdownDescription: "User email address. Either id or email must be provided.",
                                Optional:            true,
                                Computed:            true,
                        },
                        "first_name": schema.StringAttribute{
                                MarkdownDescription: "User's first name",
                                Computed:            true,
                        },
                        "last_name": schema.StringAttribute{
                                MarkdownDescription: "User's last name",
                                Computed:            true,
                        },
                        "role": schema.StringAttribute{
                                MarkdownDescription: "User role (e.g., 'admin', 'member', 'editor')",
                                Computed:            true,
                        },
                        "is_owner": schema.BoolAttribute{
                                MarkdownDescription: "Whether the user is an owner of the n8n instance",
                                Computed:            true,
                        },
                        "is_pending": schema.BoolAttribute{
                                MarkdownDescription: "Whether the user invitation is pending",
                                Computed:            true,
                        },
                        "settings": schema.SingleNestedAttribute{
                                MarkdownDescription: "User-specific settings",
                                Computed:            true,
                                Attributes: map[string]schema.Attribute{
                                        "theme": schema.StringAttribute{
                                                MarkdownDescription: "User's preferred theme (e.g., 'light', 'dark')",
                                                Computed:            true,
                                        },
                                        "allow_sso_manual_login": schema.BoolAttribute{
                                                MarkdownDescription: "Whether to allow SSO manual login for this user",
                                                Computed:            true,
                                        },
                                },
                        },
                        "created_at": schema.StringAttribute{
                                MarkdownDescription: "Timestamp when the user was created",
                                Computed:            true,
                        },
                        "updated_at": schema.StringAttribute{
                                MarkdownDescription: "Timestamp when the user was last updated",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *UserDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest,
        resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        // Prevent panic if the provider has not been configured.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, ok := req.ProviderData.(*client.Client)

        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.",
                                req.ProviderData),
                )

                return
        }</span>

        <span class="cov0" title="0">d.client = client</span>
}

func (d *UserDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data UserDataSourceModel

        // Read Terraform configuration data into the model
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Validate that either ID or email is provided
        <span class="cov0" title="0">if data.ID.IsNull() &amp;&amp; data.Email.IsNull() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing User Identifier",
                        "Either 'id' or 'email' must be provided to look up a user.",
                )
                return
        }</span>

        <span class="cov0" title="0">var user *client.User
        var err error

        // Look up user by ID if provided, otherwise by email
        if !data.ID.IsNull() </span><span class="cov0" title="0">{
                user, err = d.client.GetUser(data.ID.ValueString())
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read user by ID, got error: %s", err))
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // Look up user by email - we need to list users and find the one with matching email
                users, err := d.client.GetUsers(nil)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to list users, got error: %s", err))
                        return
                }</span>

                <span class="cov0" title="0">emailToFind := data.Email.ValueString()
                var foundUser *client.User
                for _, u := range users.Data </span><span class="cov0" title="0">{
                        if u.Email == emailToFind </span><span class="cov0" title="0">{
                                foundUser = &amp;u
                                break</span>
                        }
                }

                <span class="cov0" title="0">if foundUser == nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError("User Not Found", fmt.Sprintf("No user found with email: %s", emailToFind))
                        return
                }</span>
                <span class="cov0" title="0">user = foundUser</span>
        }

        // Update model with user data
        <span class="cov0" title="0">d.updateModelFromUser(&amp;data, user)

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

// Helper function to update model from API response
func (d *UserDataSource) updateModelFromUser(model *UserDataSourceModel, user *client.User) <span class="cov0" title="0">{
        model.ID = types.StringValue(user.ID)
        model.Email = types.StringValue(user.Email)

        if user.FirstName != "" </span><span class="cov0" title="0">{
                model.FirstName = types.StringValue(user.FirstName)
        }</span>

        <span class="cov0" title="0">if user.LastName != "" </span><span class="cov0" title="0">{
                model.LastName = types.StringValue(user.LastName)
        }</span>

        <span class="cov0" title="0">if user.Role != "" </span><span class="cov0" title="0">{
                model.Role = types.StringValue(user.Role)
        }</span>

        <span class="cov0" title="0">model.IsOwner = types.BoolValue(user.IsOwner)
        model.IsPending = types.BoolValue(user.IsPending)

        // Handle settings
        if user.Settings.Theme != "" || user.Settings.AllowSSOManualLogin </span><span class="cov0" title="0">{
                settingsAttrs := map[string]attr.Value{
                        "theme":                  types.StringValue(user.Settings.Theme),
                        "allow_sso_manual_login": types.BoolValue(user.Settings.AllowSSOManualLogin),
                }
                model.Settings = types.ObjectValueMust(
                        map[string]attr.Type{
                                "theme":                  types.StringType,
                                "allow_sso_manual_login": types.BoolType,
                        },
                        settingsAttrs,
                )
        }</span> else<span class="cov0" title="0"> {
                // Create empty settings object
                settingsAttrs := map[string]attr.Value{
                        "theme":                  types.StringNull(),
                        "allow_sso_manual_login": types.BoolNull(),
                }
                model.Settings = types.ObjectValueMust(
                        map[string]attr.Type{
                                "theme":                  types.StringType,
                                "allow_sso_manual_login": types.BoolType,
                        },
                        settingsAttrs,
                )
        }</span>

        <span class="cov0" title="0">if user.CreatedAt != nil </span><span class="cov0" title="0">{
                model.CreatedAt = types.StringValue(user.CreatedAt.Format("2006-01-02T15:04:05Z"))
        }</span>

        <span class="cov0" title="0">if user.UpdatedAt != nil </span><span class="cov0" title="0">{
                model.UpdatedAt = types.StringValue(user.UpdatedAt.Format("2006-01-02T15:04:05Z"))
        }</span>
}
</pre>

		<pre class="file" id="file13" style="display: none">package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-framework/types/basetypes"

        "github.com/devops247-online/terraform-provider-n8n/internal/client"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &amp;UserResource{}
var _ resource.ResourceWithImportState = &amp;UserResource{}

func NewUserResource() resource.Resource <span class="cov8" title="1">{
        return &amp;UserResource{}
}</span>

// UserResource defines the resource implementation.
type UserResource struct {
        client *client.Client
}

// UserResourceModel describes the resource data model.
type UserResourceModel struct {
        ID        types.String `tfsdk:"id"`
        Email     types.String `tfsdk:"email"`
        FirstName types.String `tfsdk:"first_name"`
        LastName  types.String `tfsdk:"last_name"`
        Role      types.String `tfsdk:"role"`
        Password  types.String `tfsdk:"password"`
        IsOwner   types.Bool   `tfsdk:"is_owner"`
        IsPending types.Bool   `tfsdk:"is_pending"`
        Settings  types.Object `tfsdk:"settings"`
        CreatedAt types.String `tfsdk:"created_at"`
        UpdatedAt types.String `tfsdk:"updated_at"`
}

func (r *UserResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_user"
}</span>

func (r *UserResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Manages an n8n user. This resource allows you to create, read, update, " +
                        "and delete users in your n8n instance.",

                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "User identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "email": schema.StringAttribute{
                                MarkdownDescription: "User email address. This is required and must be unique.",
                                Required:            true,
                        },
                        "first_name": schema.StringAttribute{
                                MarkdownDescription: "User's first name",
                                Optional:            true,
                        },
                        "last_name": schema.StringAttribute{
                                MarkdownDescription: "User's last name",
                                Optional:            true,
                        },
                        "role": schema.StringAttribute{
                                MarkdownDescription: "User role (e.g., 'admin', 'member', 'editor'). If not specified, " +
                                        "defaults to the instance default role.",
                                Optional: true,
                                Computed: true,
                        },
                        "password": schema.StringAttribute{
                                MarkdownDescription: "User password. This is sensitive data and will not be stored in the state after creation.",
                                Optional:            true,
                                Sensitive:           true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "is_owner": schema.BoolAttribute{
                                MarkdownDescription: "Whether the user is an owner of the n8n instance",
                                Computed:            true,
                        },
                        "is_pending": schema.BoolAttribute{
                                MarkdownDescription: "Whether the user invitation is pending",
                                Computed:            true,
                        },
                        "settings": schema.SingleNestedAttribute{
                                MarkdownDescription: "User-specific settings",
                                Optional:            true,
                                Computed:            true,
                                Attributes: map[string]schema.Attribute{
                                        "theme": schema.StringAttribute{
                                                MarkdownDescription: "User's preferred theme (e.g., 'light', 'dark')",
                                                Optional:            true,
                                        },
                                        "allow_sso_manual_login": schema.BoolAttribute{
                                                MarkdownDescription: "Whether to allow SSO manual login for this user",
                                                Optional:            true,
                                        },
                                },
                        },
                        "created_at": schema.StringAttribute{
                                MarkdownDescription: "Timestamp when the user was created",
                                Computed:            true,
                        },
                        "updated_at": schema.StringAttribute{
                                MarkdownDescription: "Timestamp when the user was last updated",
                                Computed:            true,
                        },
                },
        }
}</span>

func (r *UserResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        // Prevent panic if the provider has not been configured.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, ok := req.ProviderData.(*client.Client)

        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.",
                                req.ProviderData),
                )

                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *UserResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data UserResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Create user request object
        <span class="cov0" title="0">createReq := &amp;client.CreateUserRequest{
                Email:     data.Email.ValueString(),
                FirstName: data.FirstName.ValueString(),
                LastName:  data.LastName.ValueString(),
                Role:      data.Role.ValueString(),
                Password:  data.Password.ValueString(),
        }

        // Create user via API
        createdUser, err := r.client.CreateUser(createReq)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create user, got error: %s", err))
                return
        }</span>

        // Fetch complete user data after creation (creation response may not include all fields)
        <span class="cov0" title="0">completeUser, err := r.client.GetUser(createdUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read created user, got error: %s", err))
                return
        }</span>

        // Update model with complete user data
        <span class="cov0" title="0">r.updateModelFromUser(&amp;data, completeUser)

        // Keep password in state (it's marked as sensitive, so it's secure)

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *UserResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data UserResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get user from API
        <span class="cov0" title="0">user, err := r.client.GetUser(data.ID.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read user, got error: %s", err))
                return
        }</span>

        // Preserve the existing password from state (API doesn't return passwords)
        <span class="cov0" title="0">existingPassword := data.Password

        // Update model with response data
        r.updateModelFromUser(&amp;data, user)

        // Restore the password field
        data.Password = existingPassword

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *UserResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data UserResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Create user object for update
        <span class="cov0" title="0">user := &amp;client.User{
                Email:     data.Email.ValueString(),
                FirstName: data.FirstName.ValueString(),
                LastName:  data.LastName.ValueString(),
                Role:      data.Role.ValueString(),
        }

        // Handle settings if provided
        if !data.Settings.IsNull() </span><span class="cov0" title="0">{
                var settings client.UserSettings
                resp.Diagnostics.Append(data.Settings.As(ctx, &amp;settings, basetypes.ObjectAsOptions{})...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">user.Settings = settings</span>
        }

        // Update user via API
        <span class="cov0" title="0">updatedUser, err := r.client.UpdateUser(data.ID.ValueString(), user)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update user, got error: %s", err))
                return
        }</span>

        // Update model with response data
        <span class="cov0" title="0">r.updateModelFromUser(&amp;data, updatedUser)

        // Clear the password from state for security (it's not returned by the API)
        data.Password = types.StringNull()

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *UserResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data UserResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Delete user via API
        <span class="cov0" title="0">err := r.client.DeleteUser(data.ID.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete user, got error: %s", err))
                return
        }</span>
}

func (r *UserResource) ImportState(ctx context.Context, req resource.ImportStateRequest,
        resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>

// Helper function to update model from API response
func (r *UserResource) updateModelFromUser(model *UserResourceModel, user *client.User) <span class="cov0" title="0">{
        model.ID = types.StringValue(user.ID)
        model.Email = types.StringValue(user.Email)

        if user.FirstName != "" </span><span class="cov0" title="0">{
                model.FirstName = types.StringValue(user.FirstName)
        }</span>

        <span class="cov0" title="0">if user.LastName != "" </span><span class="cov0" title="0">{
                model.LastName = types.StringValue(user.LastName)
        }</span>

        <span class="cov0" title="0">if user.Role != "" </span><span class="cov0" title="0">{
                model.Role = types.StringValue(user.Role)
        }</span>

        <span class="cov0" title="0">model.IsOwner = types.BoolValue(user.IsOwner)
        model.IsPending = types.BoolValue(user.IsPending)

        // Handle settings (always set to ensure known value)
        settingsAttrs := map[string]attr.Value{
                "theme":                  types.StringValue(user.Settings.Theme),
                "allow_sso_manual_login": types.BoolValue(user.Settings.AllowSSOManualLogin),
        }
        model.Settings = types.ObjectValueMust(
                map[string]attr.Type{
                        "theme":                  types.StringType,
                        "allow_sso_manual_login": types.BoolType,
                },
                settingsAttrs,
        )

        if user.CreatedAt != nil </span><span class="cov0" title="0">{
                model.CreatedAt = types.StringValue(user.CreatedAt.Format("2006-01-02T15:04:05Z"))
        }</span> else<span class="cov0" title="0"> {
                model.CreatedAt = types.StringNull()
        }</span>

        <span class="cov0" title="0">if user.UpdatedAt != nil </span><span class="cov0" title="0">{
                model.UpdatedAt = types.StringValue(user.UpdatedAt.Format("2006-01-02T15:04:05Z"))
        }</span> else<span class="cov0" title="0"> {
                model.UpdatedAt = types.StringNull()
        }</span>
}
</pre>

		<pre class="file" id="file14" style="display: none">package provider

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"

        "github.com/devops247-online/terraform-provider-n8n/internal/client"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &amp;WorkflowResource{}
var _ resource.ResourceWithImportState = &amp;WorkflowResource{}

func NewWorkflowResource() resource.Resource <span class="cov8" title="1">{
        return &amp;WorkflowResource{}
}</span>

// WorkflowResource defines the resource implementation.
type WorkflowResource struct {
        client *client.Client
}

// WorkflowResourceModel describes the resource data model.
type WorkflowResourceModel struct {
        ID          types.String `tfsdk:"id"`
        Name        types.String `tfsdk:"name"`
        Active      types.Bool   `tfsdk:"active"`
        Nodes       types.String `tfsdk:"nodes"`
        Connections types.String `tfsdk:"connections"`
        Settings    types.String `tfsdk:"settings"`
        StaticData  types.String `tfsdk:"static_data"`
        PinnedData  types.String `tfsdk:"pinned_data"`
        Tags        types.List   `tfsdk:"tags"`
        VersionID   types.String `tfsdk:"version_id"`
        CreatedAt   types.String `tfsdk:"created_at"`
        UpdatedAt   types.String `tfsdk:"updated_at"`
}

func (r *WorkflowResource) Metadata(ctx context.Context, req resource.MetadataRequest,
        resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_workflow"
}</span>

func (r *WorkflowResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Manages an n8n workflow. Workflows are the core automation units in " +
                        "n8n that define a series of nodes and their connections.",

                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Workflow identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "The name of the workflow",
                                Required:            true,
                        },
                        "active": schema.BoolAttribute{
                                MarkdownDescription: "Whether the workflow is active and can be triggered",
                                Optional:            true,
                                Computed:            true,
                                Default:             booldefault.StaticBool(false),
                        },
                        "nodes": schema.StringAttribute{
                                MarkdownDescription: "JSON string containing the workflow nodes configuration",
                                Optional:            true,
                                Computed:            true,
                        },
                        "connections": schema.StringAttribute{
                                MarkdownDescription: "JSON string containing the workflow connections between nodes",
                                Optional:            true,
                                Computed:            true,
                        },
                        "settings": schema.StringAttribute{
                                MarkdownDescription: "JSON string containing workflow settings",
                                Optional:            true,
                                Computed:            true,
                        },
                        "static_data": schema.StringAttribute{
                                MarkdownDescription: "JSON string containing static data for the workflow",
                                Optional:            true,
                                Computed:            true,
                        },
                        "pinned_data": schema.StringAttribute{
                                MarkdownDescription: "JSON string containing pinned data for testing purposes",
                                Optional:            true,
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                MarkdownDescription: "List of tags associated with the workflow",
                                ElementType:         types.StringType,
                                Optional:            true,
                                Computed:            true,
                                Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
                        },
                        "version_id": schema.StringAttribute{
                                MarkdownDescription: "Version identifier of the workflow",
                                Computed:            true,
                        },
                        "created_at": schema.StringAttribute{
                                MarkdownDescription: "Timestamp when the workflow was created",
                                Computed:            true,
                        },
                        "updated_at": schema.StringAttribute{
                                MarkdownDescription: "Timestamp when the workflow was last updated",
                                Computed:            true,
                        },
                },
        }
}</span>

func (r *WorkflowResource) Configure(ctx context.Context, req resource.ConfigureRequest,
        resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        // Prevent panic if the provider has not been configured.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, ok := req.ProviderData.(*client.Client)

        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.",
                                req.ProviderData),
                )

                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *WorkflowResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data WorkflowResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Create workflow object
        <span class="cov0" title="0">workflow := &amp;client.Workflow{
                Name:   data.Name.ValueString(),
                Active: data.Active.ValueBool(),
        }

        // Parse and validate JSON fields if provided
        if !data.Nodes.IsNull() &amp;&amp; data.Nodes.ValueString() != "" </span><span class="cov0" title="0">{
                if err := r.validateWorkflowJSON(data.Nodes.ValueString(), "nodes"); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("nodes"),
                                "Invalid Nodes JSON",
                                err.Error(),
                        )
                        return
                }</span>
                <span class="cov0" title="0">var nodes map[string]interface{}
                if err := json.Unmarshal([]byte(data.Nodes.ValueString()), &amp;nodes); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("nodes"),
                                "Invalid JSON",
                                fmt.Sprintf("Unable to parse nodes JSON: %s", err),
                        )
                        return
                }</span>
                // Convert nodes from object format to array format for API
                <span class="cov0" title="0">nodesArray := r.convertNodesToArray(nodes)
                workflow.Nodes = nodesArray</span>
        }

        // Connections field is required by n8n API, default to empty object if not provided
        <span class="cov0" title="0">if !data.Connections.IsNull() &amp;&amp; data.Connections.ValueString() != "" </span><span class="cov0" title="0">{
                if err := r.validateWorkflowJSON(data.Connections.ValueString(), "connections"); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("connections"),
                                "Invalid Connections JSON",
                                err.Error(),
                        )
                        return
                }</span>
                <span class="cov0" title="0">var connections map[string]interface{}
                if err := json.Unmarshal([]byte(data.Connections.ValueString()), &amp;connections); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("connections"),
                                "Invalid JSON",
                                fmt.Sprintf("Unable to parse connections JSON: %s", err),
                        )
                        return
                }</span>
                <span class="cov0" title="0">workflow.Connections = connections</span>
        } else<span class="cov0" title="0"> {
                // Set empty connections object if not provided (required by n8n API)
                workflow.Connections = make(map[string]interface{})
        }</span>

        // Settings field is required by n8n API, default to basic settings if not provided
        <span class="cov0" title="0">if !data.Settings.IsNull() &amp;&amp; data.Settings.ValueString() != "" </span><span class="cov0" title="0">{
                var settings map[string]interface{}
                if err := json.Unmarshal([]byte(data.Settings.ValueString()), &amp;settings); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("settings"),
                                "Invalid JSON",
                                fmt.Sprintf("Unable to parse settings JSON: %s", err),
                        )
                        return
                }</span>
                <span class="cov0" title="0">workflow.Settings = settings</span>
        } else<span class="cov0" title="0"> {
                // Set basic settings if not provided (required by n8n API)
                workflow.Settings = map[string]interface{}{
                        "executionOrder": "v1",
                }
        }</span>

        <span class="cov0" title="0">if !data.StaticData.IsNull() &amp;&amp; data.StaticData.ValueString() != "" </span><span class="cov0" title="0">{
                var staticData map[string]interface{}
                if err := json.Unmarshal([]byte(data.StaticData.ValueString()), &amp;staticData); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("static_data"),
                                "Invalid JSON",
                                fmt.Sprintf("Unable to parse static_data JSON: %s", err),
                        )
                        return
                }</span>
                <span class="cov0" title="0">workflow.StaticData = staticData</span>
        }

        <span class="cov0" title="0">if !data.PinnedData.IsNull() &amp;&amp; data.PinnedData.ValueString() != "" </span><span class="cov0" title="0">{
                var pinnedData map[string]interface{}
                if err := json.Unmarshal([]byte(data.PinnedData.ValueString()), &amp;pinnedData); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("pinned_data"),
                                "Invalid JSON",
                                fmt.Sprintf("Unable to parse pinned_data JSON: %s", err),
                        )
                        return
                }</span>
                <span class="cov0" title="0">workflow.PinnedData = pinnedData</span>
        }

        // Tags are read-only during creation, will be set via update if needed

        // Create workflow via API
        <span class="cov0" title="0">createdWorkflow, err := r.client.CreateWorkflow(workflow)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create workflow, got error: %s", err))
                return
        }</span>

        // TODO: Tags are read-only in n8n API, need to investigate proper tag management approach

        // Update model with response data
        <span class="cov0" title="0">r.updateModelFromWorkflow(&amp;data, createdWorkflow)

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *WorkflowResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data WorkflowResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get workflow from API
        <span class="cov0" title="0">workflow, err := r.client.GetWorkflow(data.ID.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read workflow, got error: %s", err))
                return
        }</span>

        // Update model with response data
        <span class="cov0" title="0">r.updateModelFromWorkflow(&amp;data, workflow)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *WorkflowResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data WorkflowResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Create workflow object for update
        <span class="cov0" title="0">workflow := &amp;client.Workflow{
                Name:   data.Name.ValueString(),
                Active: data.Active.ValueBool(),
        }

        // Parse and validate JSON fields if provided (similar to Create method)
        if !data.Nodes.IsNull() &amp;&amp; data.Nodes.ValueString() != "" </span><span class="cov0" title="0">{
                if err := r.validateWorkflowJSON(data.Nodes.ValueString(), "nodes"); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("nodes"),
                                "Invalid Nodes JSON",
                                err.Error(),
                        )
                        return
                }</span>
                <span class="cov0" title="0">var nodes map[string]interface{}
                if err := json.Unmarshal([]byte(data.Nodes.ValueString()), &amp;nodes); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("nodes"),
                                "Invalid JSON",
                                fmt.Sprintf("Unable to parse nodes JSON: %s", err),
                        )
                        return
                }</span>
                // Convert nodes from object format to array format for API
                <span class="cov0" title="0">nodesArray := r.convertNodesToArray(nodes)
                workflow.Nodes = nodesArray</span>
        }

        // Connections field is required by n8n API, default to empty object if not provided
        <span class="cov0" title="0">if !data.Connections.IsNull() &amp;&amp; data.Connections.ValueString() != "" </span><span class="cov0" title="0">{
                if err := r.validateWorkflowJSON(data.Connections.ValueString(), "connections"); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("connections"),
                                "Invalid Connections JSON",
                                err.Error(),
                        )
                        return
                }</span>
                <span class="cov0" title="0">var connections map[string]interface{}
                if err := json.Unmarshal([]byte(data.Connections.ValueString()), &amp;connections); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("connections"),
                                "Invalid JSON",
                                fmt.Sprintf("Unable to parse connections JSON: %s", err),
                        )
                        return
                }</span>
                <span class="cov0" title="0">workflow.Connections = connections</span>
        } else<span class="cov0" title="0"> {
                // Set empty connections object if not provided (required by n8n API)
                workflow.Connections = make(map[string]interface{})
        }</span>

        // Settings field is required by n8n API, default to basic settings if not provided
        <span class="cov0" title="0">if !data.Settings.IsNull() &amp;&amp; data.Settings.ValueString() != "" </span><span class="cov0" title="0">{
                var settings map[string]interface{}
                if err := json.Unmarshal([]byte(data.Settings.ValueString()), &amp;settings); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("settings"),
                                "Invalid JSON",
                                fmt.Sprintf("Unable to parse settings JSON: %s", err),
                        )
                        return
                }</span>
                <span class="cov0" title="0">workflow.Settings = settings</span>
        } else<span class="cov0" title="0"> {
                // Set basic settings if not provided (required by n8n API)
                workflow.Settings = map[string]interface{}{
                        "executionOrder": "v1",
                }
        }</span>

        <span class="cov0" title="0">if !data.StaticData.IsNull() &amp;&amp; data.StaticData.ValueString() != "" </span><span class="cov0" title="0">{
                var staticData map[string]interface{}
                if err := json.Unmarshal([]byte(data.StaticData.ValueString()), &amp;staticData); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("static_data"),
                                "Invalid JSON",
                                fmt.Sprintf("Unable to parse static_data JSON: %s", err),
                        )
                        return
                }</span>
                <span class="cov0" title="0">workflow.StaticData = staticData</span>
        }

        <span class="cov0" title="0">if !data.PinnedData.IsNull() &amp;&amp; data.PinnedData.ValueString() != "" </span><span class="cov0" title="0">{
                var pinnedData map[string]interface{}
                if err := json.Unmarshal([]byte(data.PinnedData.ValueString()), &amp;pinnedData); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddAttributeError(
                                path.Root("pinned_data"),
                                "Invalid JSON",
                                fmt.Sprintf("Unable to parse pinned_data JSON: %s", err),
                        )
                        return
                }</span>
                <span class="cov0" title="0">workflow.PinnedData = pinnedData</span>
        }

        // Handle tags
        <span class="cov0" title="0">if !data.Tags.IsNull() </span><span class="cov0" title="0">{
                var tags []string
                resp.Diagnostics.Append(data.Tags.ElementsAs(ctx, &amp;tags, false)...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">workflow.Tags = tags</span>
        }

        // Update workflow via API
        <span class="cov0" title="0">updatedWorkflow, err := r.client.UpdateWorkflow(data.ID.ValueString(), workflow)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update workflow, got error: %s", err))
                return
        }</span>

        // Update model with response data
        <span class="cov0" title="0">r.updateModelFromWorkflow(&amp;data, updatedWorkflow)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *WorkflowResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data WorkflowResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Delete workflow via API
        <span class="cov0" title="0">err := r.client.DeleteWorkflow(data.ID.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete workflow, got error: %s", err))
                return
        }</span>
}

func (r *WorkflowResource) ImportState(ctx context.Context, req resource.ImportStateRequest,
        resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>

// validateWorkflowJSON validates the JSON structure of workflow fields
func (r *WorkflowResource) validateWorkflowJSON(jsonStr string, fieldName string) error <span class="cov0" title="0">{
        if jsonStr == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        if err := json.Unmarshal([]byte(jsonStr), &amp;result); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid JSON in %s: %w", fieldName, err)
        }</span>

        // Additional validation for specific fields
        <span class="cov0" title="0">switch fieldName </span>{
        case "nodes":<span class="cov0" title="0">
                // Validate nodes structure - should be a map where each key represents a node
                for nodeKey, nodeValue := range result </span><span class="cov0" title="0">{
                        if nodeMap, ok := nodeValue.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                // Check for required node properties
                                if _, hasType := nodeMap["type"]; !hasType </span><span class="cov0" title="0">{
                                        return fmt.Errorf("node %s is missing required 'type' field", nodeKey)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return fmt.Errorf("node %s must be an object", nodeKey)
                        }</span>
                }
        case "connections":<span class="cov0" title="0">
                // Validate connections structure - should be a map of arrays
                for sourceNode, connections := range result </span><span class="cov0" title="0">{
                        if connArray, ok := connections.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                for outputType, outputConnections := range connArray </span><span class="cov0" title="0">{
                                        if connectionsList, ok := outputConnections.([]interface{}); ok </span><span class="cov0" title="0">{
                                                for i, conn := range connectionsList </span><span class="cov0" title="0">{
                                                        if connMap, ok := conn.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                                if _, hasNode := connMap["node"]; !hasNode </span><span class="cov0" title="0">{
                                                                        return fmt.Errorf("connection %d from %s.%s is missing required 'node' field", i, sourceNode, outputType)
                                                                }</span>
                                                                <span class="cov0" title="0">if _, hasType := connMap["type"]; !hasType </span><span class="cov0" title="0">{
                                                                        return fmt.Errorf("connection %d from %s.%s is missing required 'type' field", i, sourceNode, outputType)
                                                                }</span>
                                                                <span class="cov0" title="0">if _, hasIndex := connMap["index"]; !hasIndex </span><span class="cov0" title="0">{
                                                                        return fmt.Errorf("connection %d from %s.%s is missing required 'index' field", i, sourceNode, outputType)
                                                                }</span>
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper function to update model from API response
func (r *WorkflowResource) updateModelFromWorkflow(model *WorkflowResourceModel, workflow *client.Workflow) <span class="cov0" title="0">{
        model.ID = types.StringValue(workflow.ID)
        model.Name = types.StringValue(workflow.Name)
        model.Active = types.BoolValue(workflow.Active)

        // Convert JSON fields to strings
        if workflow.Nodes != nil </span><span class="cov0" title="0">{
                // Convert nodes from API array format to Terraform object format
                nodesObject := r.convertNodesFromArray(workflow.Nodes)
                if nodesJSON, err := json.Marshal(nodesObject); err == nil </span><span class="cov0" title="0">{
                        model.Nodes = types.StringValue(string(nodesJSON))
                }</span>
        }

        <span class="cov0" title="0">if workflow.Connections != nil </span><span class="cov0" title="0">{
                if connectionsJSON, err := json.Marshal(workflow.Connections); err == nil </span><span class="cov0" title="0">{
                        model.Connections = types.StringValue(string(connectionsJSON))
                }</span>
        }

        <span class="cov0" title="0">if workflow.Settings != nil </span><span class="cov0" title="0">{
                if settingsJSON, err := json.Marshal(workflow.Settings); err == nil </span><span class="cov0" title="0">{
                        model.Settings = types.StringValue(string(settingsJSON))
                }</span>
        }

        <span class="cov0" title="0">if workflow.StaticData != nil </span><span class="cov0" title="0">{
                if staticDataJSON, err := json.Marshal(workflow.StaticData); err == nil </span><span class="cov0" title="0">{
                        model.StaticData = types.StringValue(string(staticDataJSON))
                }</span>
        } else<span class="cov0" title="0"> {
                model.StaticData = types.StringNull()
        }</span>

        <span class="cov0" title="0">if workflow.PinnedData != nil </span><span class="cov0" title="0">{
                if pinnedDataJSON, err := json.Marshal(workflow.PinnedData); err == nil </span><span class="cov0" title="0">{
                        model.PinnedData = types.StringValue(string(pinnedDataJSON))
                }</span>
        } else<span class="cov0" title="0"> {
                model.PinnedData = types.StringNull()
        }</span>

        // Handle tags
        <span class="cov0" title="0">if workflow.Tags != nil </span><span class="cov0" title="0">{
                tagValues := make([]attr.Value, len(workflow.Tags))
                for i, tag := range workflow.Tags </span><span class="cov0" title="0">{
                        tagValues[i] = types.StringValue(tag)
                }</span>
                <span class="cov0" title="0">model.Tags = types.ListValueMust(types.StringType, tagValues)</span>
        }

        <span class="cov0" title="0">if workflow.VersionID != "" </span><span class="cov0" title="0">{
                model.VersionID = types.StringValue(workflow.VersionID)
        }</span>

        <span class="cov0" title="0">if workflow.CreatedAt != nil </span><span class="cov0" title="0">{
                model.CreatedAt = types.StringValue(workflow.CreatedAt.Format("2006-01-02T15:04:05Z"))
        }</span>

        <span class="cov0" title="0">if workflow.UpdatedAt != nil </span><span class="cov0" title="0">{
                model.UpdatedAt = types.StringValue(workflow.UpdatedAt.Format("2006-01-02T15:04:05Z"))
        }</span>
}

// convertNodesToArray converts nodes from Terraform's object format to n8n API's array format
func (r *WorkflowResource) convertNodesToArray(nodes map[string]interface{}) []interface{} <span class="cov0" title="0">{
        var nodesArray []interface{}

        for nodeId, nodeData := range nodes </span><span class="cov0" title="0">{
                if nodeMap, ok := nodeData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // Add the node ID to the node data
                        nodeMap["id"] = nodeId
                        nodesArray = append(nodesArray, nodeMap)
                }</span>
        }

        <span class="cov0" title="0">return nodesArray</span>
}

// convertNodesFromArray converts nodes from n8n API's array format to Terraform's object format
func (r *WorkflowResource) convertNodesFromArray(nodesArray []interface{}) map[string]interface{} <span class="cov0" title="0">{
        nodesObject := make(map[string]interface{})

        for _, nodeData := range nodesArray </span><span class="cov0" title="0">{
                if nodeMap, ok := nodeData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if nodeId, exists := nodeMap["id"]; exists </span><span class="cov0" title="0">{
                                if nodeIdStr, ok := nodeId.(string); ok </span><span class="cov0" title="0">{
                                        // Remove the id field from the node data since it becomes the key
                                        nodeCopy := make(map[string]interface{})
                                        for k, v := range nodeMap </span><span class="cov0" title="0">{
                                                if k != "id" </span><span class="cov0" title="0">{
                                                        nodeCopy[k] = v
                                                }</span>
                                        }
                                        <span class="cov0" title="0">nodesObject[nodeIdStr] = nodeCopy</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return nodesObject</span>
}
</pre>

		<pre class="file" id="file15" style="display: none">package main

import (
        "context"
        "flag"
        "log"

        "github.com/hashicorp/terraform-plugin-framework/providerserver"

        "github.com/devops247-online/terraform-provider-n8n/internal/provider"
)

// Run "go generate" to format example terraform files and generate the docs
//go:generate sh -c "terraform fmt -recursive ./examples/ 2&gt;/dev/null || true"
//go:generate go run github.com/hashicorp/terraform-plugin-docs/cmd/tfplugindocs

var (
        // version is set via build ldflags
        version string = "dev"
)

func main() <span class="cov0" title="0">{
        var debug bool

        flag.BoolVar(&amp;debug, "debug", false, "set to true to run the provider with support for debuggers like delve")
        flag.Parse()

        opts := providerserver.ServeOpts{
                Address: "registry.terraform.io/devops247-online/n8n",
                Debug:   debug,
        }

        err := providerserver.Serve(context.Background(), provider.New(version), opts)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err.Error())
        }</span>
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
